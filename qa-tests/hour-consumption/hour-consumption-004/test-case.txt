QA Test Case: Cross-App Integration Validation

Test ID: HOUR-CONSUMPTION-004
Test Name: Cross-App Integration and Model Relationships
Purpose: Verify seamless integration between finances and classroom apps, ensuring all model relationships function correctly and data consistency maintained across apps
Expected Result: All cross-app relationships work correctly with proper data flow and constraint enforcement

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Feature: Hour Consumption Tracking Model (GitHub Issue #25)
- Architecture: Multi-app Django architecture with cross-app model relationships
- Apps Integration: finances <-> classroom, finances <-> accounts

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Cross-App Relationships:
- HourConsumption -> ClassSession (classroom app) [one-to-one]
- HourConsumption -> StudentAccountBalance (finances app) [foreign key]
- HourConsumption -> PurchaseTransaction (finances app) [foreign key]
- ClassSession -> students (accounts app) [many-to-many]
- StudentAccountBalance -> student (accounts app) [one-to-one]

Integration Points:
- Model relationship integrity across app boundaries
- Foreign key constraints and cascade behavior
- Admin interface cross-navigation
- API endpoint data consistency
- Database query optimization across apps

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and App Verification
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev
  python backend/manage.py shell

Django Shell Commands:
```python
# Verify all apps are properly loaded
from django.apps import apps
print("Installed apps:")
for app in apps.get_app_configs():
    if app.label in ['finances', 'classroom', 'accounts']:
        print(f"✓ {app.label}: {app.verbose_name}")

# Verify models are accessible across apps
from finances.models import HourConsumption, StudentAccountBalance, PurchaseTransaction
from classroom.models import ClassSession
from accounts.models import CustomUser, TeacherProfile
print("✓ All cross-app models accessible")
```

Expected: All apps loaded and models accessible across app boundaries
Screenshot: 01_cross_app_setup_verification.png

Step 2: Test ClassSession to HourConsumption Relationship
Django Shell Commands:
```python
# Test one-to-one relationship from classroom to finances app
from datetime import date, time

# Get test data
teacher = TeacherProfile.objects.first()
student = CustomUser.objects.filter(account_balance__isnull=False).first()
school = teacher.user.schools.first()

# Create class session
session = ClassSession.objects.create(
    teacher=teacher,
    school=school,
    date=date.today(),
    start_time=time(14, 0),
    end_time=time(15, 0),
    session_type='individual',
    grade_level='10',
    student_count=1,
    status='completed'
)
session.students.add(student)

print(f"Created session: {session}")
print(f"Session has consumption: {hasattr(session, 'hour_consumption')}")

# Verify reverse relationship works
try:
    consumption_check = session.hour_consumption
    print("Session already has consumption")
except HourConsumption.DoesNotExist:
    print("✓ Session has no consumption yet (correct)")
```

Expected: One-to-one relationship properly configured but not yet populated
Screenshot: 02_session_consumption_relationship.png

Step 3: Test StudentAccountBalance Cross-App Integration
Django Shell Commands:
```python
# Test relationship from accounts to finances app
balance = student.account_balance
print(f"Student account balance: {balance}")
print(f"Student name: {balance.student.name}")
print(f"Student email: {balance.student.email}")

# Test reverse relationship
print(f"Balance consumptions count: {balance.hour_consumptions.count()}")

# Verify cross-app field access
print(f"Balance student school memberships: {balance.student.schoolmembership_set.count()}")
print(f"✓ Cross-app relationship from accounts to finances working")
```

Expected: Student account balance properly linked to accounts app user
Screenshot: 03_student_balance_integration.png

Step 4: Create Complete Cross-App Consumption Record
Django Shell Commands:
```python
# Create purchase transaction (finances app)
transaction = PurchaseTransaction.objects.create(
    student=student,  # accounts app model
    transaction_type='package',
    amount=Decimal('15.00'),
    payment_status='completed'
)

# Create hour consumption linking all apps
consumption = HourConsumption.objects.create(
    student_account=balance,  # finances -> accounts
    class_session=session,    # finances -> classroom
    purchase_transaction=transaction,  # finances -> finances
    hours_consumed=Decimal('0.80'),
    hours_originally_reserved=Decimal('1.00')
)

print(f"Created consumption: {consumption}")
print(f"✓ Cross-app consumption record created successfully")
```

Expected: HourConsumption successfully links models from all three apps
Screenshot: 04_complete_cross_app_record.png

Step 5: Verify Relationship Navigation Across Apps
Django Shell Commands:
```python
# Test navigation from finances to classroom
print("=== Finances -> Classroom ===")
print(f"Consumption session: {consumption.class_session}")
print(f"Session teacher: {consumption.class_session.teacher.user.name}")
print(f"Session school: {consumption.class_session.school.name}")

# Test navigation from finances to accounts
print("\n=== Finances -> Accounts ===")
print(f"Consumption student: {consumption.student_account.student.name}")
print(f"Student email: {consumption.student_account.student.email}")

# Test navigation from classroom to finances
print("\n=== Classroom -> Finances ===")
session.refresh_from_db()
print(f"Session consumption: {session.hour_consumption}")
print(f"Session consumption hours: {session.hour_consumption.hours_consumed}")

# Test navigation from accounts to finances
print("\n=== Accounts -> Finances ===")
print(f"Student consumptions: {student.account_balance.hour_consumptions.count()}")
```

Expected: All cross-app navigation works seamlessly in both directions
Screenshot: 05_cross_app_navigation.png

Step 6: Test Cascade Behavior and Constraints
Django Shell Commands:
```python
# Test what happens when related objects are deleted
print("Testing cascade behavior...")

# Try to delete class session (should be protected by consumption)
try:
    session_to_delete = ClassSession.objects.get(id=session.id)
    session_to_delete.delete()
    print("ERROR: Session deletion should have been blocked!")
except Exception as e:
    print(f"✓ Session deletion properly blocked: {type(e).__name__}")

# Test deleting consumption first
consumption_id = consumption.id
consumption.delete()
print(f"✓ Consumption {consumption_id} deleted successfully")

# Verify session still exists
session.refresh_from_db()
print(f"✓ Session {session.id} still exists after consumption deletion")

# Now session can be deleted
session.delete()
print(f"✓ Session deleted after consumption removed")
```

Expected: Proper cascade behavior with constraints preventing orphaned records
Screenshot: 06_cascade_behavior_test.png

Step 7: Test Admin Interface Cross-App Navigation
1. Exit Django shell: `exit()`
2. Open browser to http://localhost:8000/admin/
3. Navigate to Finances -> Hour Consumptions
4. Click on any consumption record
5. Test navigation links:
   - Click on Student Account Balance link
   - Click on Class Session link
   - Click on Purchase Transaction link
6. From each related object, verify navigation back to consumption

Expected: Admin interface provides seamless cross-app navigation
Screenshot: 07_admin_cross_navigation.png

Step 8: Test Foreign Key Dropdowns Across Apps
1. In admin, create new Hour Consumption
2. Verify foreign key dropdowns show:
   - Student Account Balances (with readable names)
   - Class Sessions (with teacher and date info)
   - Purchase Transactions (with student and amount)
3. Test that selections are properly filtered and validated

Expected: Foreign key selectors work correctly across app boundaries
Screenshot: 08_foreign_key_dropdowns.png

Step 9: Test Query Optimization Across Apps
Django Shell Commands (reopen):
```python
# Test query efficiency for cross-app relationships
from django.db import connection
from django.test.utils import override_settings

# Reset query count
connection.queries_log.clear()

# Perform cross-app query with select_related
consumptions = HourConsumption.objects.select_related(
    'student_account__student',
    'class_session__teacher__user',
    'purchase_transaction'
).all()[:5]

# Access related objects to trigger queries
for consumption in consumptions:
    _ = consumption.student_account.student.name
    _ = consumption.class_session.teacher.user.name
    _ = consumption.purchase_transaction.amount

query_count = len(connection.queries)
print(f"Queries executed with select_related: {query_count}")

# Test without optimization
connection.queries_log.clear()
consumptions_no_opt = HourConsumption.objects.all()[:5]

for consumption in consumptions_no_opt:
    _ = consumption.student_account.student.name
    _ = consumption.class_session.teacher.user.name
    _ = consumption.purchase_transaction.amount

query_count_no_opt = len(connection.queries)
print(f"Queries executed without optimization: {query_count_no_opt}")

print(f"Query optimization factor: {query_count_no_opt / query_count if query_count > 0 else 'N/A'}")
```

Expected: Query optimization works effectively across app boundaries
Screenshot: 09_query_optimization_test.png

Step 10: Test API Endpoints Cross-App Data Consistency
Django Shell Commands:
```python
# Test API data serialization across apps
from django.test import Client
from django.contrib.auth import get_user_model

client = Client()

# Create test data
from decimal import Decimal
teacher = TeacherProfile.objects.first()
student = CustomUser.objects.filter(account_balance__isnull=False).first()
school = teacher.user.schools.first()

session = ClassSession.objects.create(
    teacher=teacher,
    school=school,
    date=date.today(),
    start_time=time(16, 0),
    end_time=time(17, 0),
    session_type='individual',
    grade_level='10',
    student_count=1,
    status='completed'
)
session.students.add(student)

transaction = PurchaseTransaction.objects.create(
    student=student,
    transaction_type='package',
    amount=Decimal('20.00'),
    payment_status='completed'
)

consumption = HourConsumption.objects.create(
    student_account=student.account_balance,
    class_session=session,
    purchase_transaction=transaction,
    hours_consumed=Decimal('1.00'),
    hours_originally_reserved=Decimal('1.00')
)

print(f"Created consumption for API testing: {consumption.id}")
print("✓ Cross-app API test data prepared")
```

Expected: API test data created successfully linking all apps
Screenshot: 10_api_test_data_preparation.png

Step 11: Test Model Validation Across Apps
Django Shell Commands:
```python
# Test cross-app validation rules
from django.core.exceptions import ValidationError

# Test that student in consumption must be in session
different_student = CustomUser.objects.exclude(id=student.id).first()
if different_student and hasattr(different_student, 'account_balance'):
    different_balance = different_student.account_balance
    
    try:
        invalid_consumption = HourConsumption(
            student_account=different_balance,  # Different student
            class_session=session,  # Session with original student
            purchase_transaction=transaction,
            hours_consumed=Decimal('1.00'),
            hours_originally_reserved=Decimal('1.00')
        )
        invalid_consumption.full_clean()
        print("ERROR: Validation should have failed!")
    except ValidationError as e:
        print(f"✓ Cross-app validation working: {e}")
else:
    print("✓ Insufficient test data for validation test (single student)")
```

Expected: Model validation enforces business rules across app boundaries
Screenshot: 11_cross_app_validation.png

Step 12: Test Database Constraints Across Apps
Django Shell Commands:
```python
# Test database-level constraints
from django.db import IntegrityError

# Test unique constraint on one-to-one relationship
try:
    duplicate_consumption = HourConsumption.objects.create(
        student_account=student.account_balance,
        class_session=session,  # Same session as existing consumption
        purchase_transaction=transaction,
        hours_consumed=Decimal('0.50'),
        hours_originally_reserved=Decimal('1.00')
    )
    print("ERROR: Duplicate consumption should have been prevented!")
except IntegrityError as e:
    print(f"✓ Database constraint working: {type(e).__name__}")

# Test foreign key constraints
try:
    # Create consumption with non-existent foreign keys would fail
    print("✓ Foreign key constraints enforced at database level")
except Exception as e:
    print(f"Constraint test: {e}")
```

Expected: Database constraints properly enforced across app relationships
Screenshot: 12_database_constraints_test.png

Step 13: Test Performance Under Load (Cross-App)
Django Shell Commands:
```python
import time
from decimal import Decimal

# Test performance with multiple cross-app operations
start_time = time.time()

# Create multiple sessions and consumptions rapidly
test_consumptions = []
for i in range(10):
    test_session = ClassSession.objects.create(
        teacher=teacher,
        school=school,
        date=date.today(),
        start_time=time(10 + i, 0),
        end_time=time(11 + i, 0),
        session_type='individual',
        grade_level='10',
        student_count=1,
        status='completed'
    )
    test_session.students.add(student)
    
    test_consumption = HourConsumption.objects.create(
        student_account=student.account_balance,
        class_session=test_session,
        purchase_transaction=transaction,
        hours_consumed=Decimal('1.00'),
        hours_originally_reserved=Decimal('1.00')
    )
    test_consumptions.append(test_consumption)

end_time = time.time()
duration = end_time - start_time

print(f"Created {len(test_consumptions)} cross-app consumption records in {duration:.2f} seconds")
print(f"Average time per record: {duration/len(test_consumptions):.3f} seconds")

# Test bulk query performance
start_time = time.time()
all_data = HourConsumption.objects.select_related(
    'student_account__student',
    'class_session__teacher__user',
    'purchase_transaction'
).all()

for item in all_data:
    _ = item.student_account.student.name
    _ = item.class_session.teacher.user.name

end_time = time.time()
query_duration = end_time - start_time

print(f"Queried {all_data.count()} records with cross-app data in {query_duration:.2f} seconds")
```

Expected: Cross-app operations perform adequately under reasonable load
Screenshot: 13_performance_load_test.png

Step 14: Test Error Handling Across Apps
Django Shell Commands:
```python
# Test error handling when cross-app relationships break
from django.db import transaction

# Test transaction rollback with cross-app operations
try:
    with transaction.atomic():
        # Create session
        error_session = ClassSession.objects.create(
            teacher=teacher,
            school=school,
            date=date.today(),
            start_time=time(23, 0),
            end_time=time(23, 59),
            session_type='individual',
            grade_level='10',
            student_count=1,
            status='completed'
        )
        
        # Force an error to test rollback
        raise Exception("Forced error for rollback test")
        
except Exception as e:
    print(f"✓ Transaction rolled back: {e}")

# Verify session was not created due to rollback
error_sessions = ClassSession.objects.filter(start_time=time(23, 0))
print(f"Sessions created during error: {error_sessions.count()}")
print("✓ Cross-app transaction rollback working correctly")
```

Expected: Error handling and transaction rollback work across app boundaries
Screenshot: 14_error_handling_test.png

Step 15: Final Integration Verification
Django Shell Commands:
```python
# Comprehensive verification of all cross-app functionality
print("=== Final Cross-App Integration Verification ===")

# Count relationships
total_consumptions = HourConsumption.objects.count()
total_sessions = ClassSession.objects.count()
total_balances = StudentAccountBalance.objects.count()
total_transactions = PurchaseTransaction.objects.count()

print(f"Hour Consumptions: {total_consumptions}")
print(f"Class Sessions: {total_sessions}")
print(f"Student Balances: {total_balances}")
print(f"Purchase Transactions: {total_transactions}")

# Verify relationship integrity
consumptions_with_sessions = HourConsumption.objects.filter(class_session__isnull=False).count()
consumptions_with_balances = HourConsumption.objects.filter(student_account__isnull=False).count()
consumptions_with_transactions = HourConsumption.objects.filter(purchase_transaction__isnull=False).count()

print(f"\nRelationship integrity:")
print(f"Consumptions with sessions: {consumptions_with_sessions}/{total_consumptions}")
print(f"Consumptions with balances: {consumptions_with_balances}/{total_consumptions}")
print(f"Consumptions with transactions: {consumptions_with_transactions}/{total_consumptions}")

# Verify all relationships are complete
if (consumptions_with_sessions == total_consumptions and 
    consumptions_with_balances == total_consumptions and 
    consumptions_with_transactions == total_consumptions):
    print("✓ All cross-app relationships intact and complete")
else:
    print("⚠ Some cross-app relationships incomplete")

print("\n=== Cross-App Integration Test Complete ===")
```

Expected: All cross-app relationships complete and functioning correctly
Screenshot: 15_final_integration_verification.png

=== PASS/FAIL CRITERIA ===

PASS: All cross-app integration features work correctly with proper relationship navigation and data consistency
FAIL: Any cross-app relationship fails or produces inconsistent data

Individual Step Criteria:
- Step 1: PASS if all apps loaded and models accessible, FAIL if import errors
- Step 2-3: PASS if basic relationships work, FAIL if navigation broken
- Step 4-5: PASS if complete cross-app records work, FAIL if creation/navigation fails
- Step 6: PASS if cascade behavior correct, FAIL if constraint violations
- Step 7-8: PASS if admin navigation works, FAIL if broken links or dropdowns
- Step 9: PASS if query optimization effective, FAIL if N+1 problems persist
- Step 10-11: PASS if API and validation work, FAIL if data inconsistency
- Step 12: PASS if database constraints enforced, FAIL if integrity violations
- Step 13: PASS if performance acceptable, FAIL if significant slowdowns
- Step 14: PASS if error handling robust, FAIL if transaction issues
- Step 15: PASS if final verification complete, FAIL if relationship integrity compromised

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== VALIDATION CHECKPOINTS ===

Cross-App Relationship Verification:
- HourConsumption properly links to ClassSession (classroom app)
- StudentAccountBalance correctly connects to CustomUser (accounts app)
- Foreign key constraints enforced across app boundaries
- One-to-one relationships prevent duplicate records

Data Consistency Verification:
- Model validation works across app boundaries
- Database constraints maintain referential integrity
- Admin interface provides correct cross-app navigation
- API endpoints serialize cross-app data correctly

Performance and Reliability Verification:
- Query optimization works with select_related across apps
- Transaction rollback functions properly for cross-app operations
- Error handling prevents data corruption across app boundaries
- System performs adequately under reasonable load