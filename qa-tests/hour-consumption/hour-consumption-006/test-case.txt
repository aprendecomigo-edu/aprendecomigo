QA Test Case: Audit Trail and Data Integrity

Test ID: HOUR-CONSUMPTION-006
Test Name: Hour Consumption Audit Trail and Data Integrity Verification
Purpose: Verify complete audit trail functionality, data integrity maintenance, and historical tracking of all hour consumption operations
Expected Result: System maintains comprehensive audit trail with data integrity across all operations

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Feature: Hour Consumption Tracking Model (GitHub Issue #25)
- Architecture: Django REST backend with comprehensive audit trail
- Focus: Data integrity, audit trail, and historical tracking

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Audit Trail Components:
- Timestamp tracking (created_at, updated_at, consumed_at)
- Refund audit trail (is_refunded, refund_reason)
- Balance change tracking through consumption creation
- Transaction linkage for complete financial audit
- Cross-model relationship integrity

Data Integrity Verification:
- Referential integrity across related models
- Cascade behavior validation
- Balance calculation consistency
- Audit log completeness and accuracy

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Audit Trail Baseline
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev
  python backend/manage.py shell

Django Shell Commands:
```python
from finances.models import HourConsumption, StudentAccountBalance, PurchaseTransaction
from classroom.models import ClassSession
from accounts.models import CustomUser, TeacherProfile
from django.utils import timezone
from decimal import Decimal
from datetime import date, time, datetime, timedelta
import time as time_module

# Set up audit trail testing
print("=== AUDIT TRAIL AND DATA INTEGRITY TESTING ===")
print(f"Test start time: {timezone.now()}")

# Get baseline counts
initial_counts = {
    'consumptions': HourConsumption.objects.count(),
    'sessions': ClassSession.objects.count(),
    'balances': StudentAccountBalance.objects.count(),
    'transactions': PurchaseTransaction.objects.count(),
}

print("Initial database state:")
for model, count in initial_counts.items():
    print(f"  {model}: {count}")

# Set up test entities
teacher = TeacherProfile.objects.first()
student = CustomUser.objects.filter(account_balance__isnull=False).first()
school = teacher.user.schools.first()
balance = student.account_balance

print(f"\nTest entities:")
print(f"  Teacher: {teacher.user.name}")
print(f"  Student: {student.name}")
print(f"  School: {school.name}")
print(f"  Initial balance consumed: {balance.hours_consumed}")
```

Expected: Audit trail testing environment prepared with baseline measurements
Screenshot: 01_audit_trail_baseline.png

Step 2: Test Timestamp Accuracy and Consistency
Django Shell Commands:
```python
# Test timestamp creation and accuracy
creation_start = timezone.now()
time_module.sleep(1)  # Ensure measurable time difference

# Create session and transaction for testing
session = ClassSession.objects.create(
    teacher=teacher,
    school=school,
    date=date.today(),
    start_time=time(14, 0),
    end_time=time(15, 0),
    session_type='individual',
    grade_level='10',
    student_count=1,
    status='completed'
)
session.students.add(student)

transaction = PurchaseTransaction.objects.create(
    student=student,
    transaction_type='package',
    amount=Decimal('10.00'),
    payment_status='completed'
)

# Record time before consumption creation
consumption_create_start = timezone.now()

# Create consumption with detailed timestamp tracking
consumption = HourConsumption.objects.create(
    student_account=balance,
    class_session=session,
    purchase_transaction=transaction,
    hours_consumed=Decimal('1.00'),
    hours_originally_reserved=Decimal('1.00')
)

consumption_create_end = timezone.now()

print(f"\nTimestamp Analysis:")
print(f"  Creation window: {consumption_create_start} to {consumption_create_end}")
print(f"  Consumption created_at: {consumption.created_at}")
print(f"  Consumption updated_at: {consumption.updated_at}")
print(f"  Consumption consumed_at: {consumption.consumed_at}")

# Verify timestamp relationships
assert consumption.created_at >= creation_start, "Created timestamp too early"
assert consumption.created_at <= consumption_create_end, "Created timestamp too late"
assert consumption.consumed_at == consumption.created_at, "Consumed_at should equal created_at"
assert consumption.updated_at == consumption.created_at, "Updated_at should equal created_at initially"

print("✓ All timestamps within expected ranges and relationships correct")
```

Expected: All timestamps accurate and consistent with creation timing
Screenshot: 02_timestamp_accuracy.png

Step 3: Test Audit Trail Through Update Operations
Django Shell Commands:
```python
# Test audit trail maintenance through updates
initial_created = consumption.created_at
initial_updated = consumption.updated_at
initial_consumed = consumption.consumed_at

time_module.sleep(1)  # Ensure timestamp difference

# Update consumption (simulate edit)
update_start = timezone.now()
consumption.hours_consumed = Decimal('0.75')  # Change consumed hours
consumption.save()
update_end = timezone.now()

consumption.refresh_from_db()

print(f"\nUpdate Audit Trail:")
print(f"  Original created_at: {initial_created}")
print(f"  Updated created_at: {consumption.created_at}")
print(f"  Original updated_at: {initial_updated}")
print(f"  New updated_at: {consumption.updated_at}")
print(f"  Original consumed_at: {initial_consumed}")
print(f"  Updated consumed_at: {consumption.consumed_at}")

# Verify audit trail behavior
assert consumption.created_at == initial_created, "Created_at should not change"
assert consumption.updated_at > initial_updated, "Updated_at should advance"
assert consumption.updated_at >= update_start, "Updated_at should be within update window"
assert consumption.consumed_at == initial_consumed, "Consumed_at should not change"

print("✓ Update audit trail maintained correctly")
```

Expected: Update operations properly maintain audit trail with correct timestamp behavior
Screenshot: 03_update_audit_trail.png

Step 4: Test Refund Audit Trail
Django Shell Commands:
```python
# Test refund processing audit trail
pre_refund_updated = consumption.updated_at
pre_refund_balance = balance.hours_consumed

time_module.sleep(1)

refund_start = timezone.now()
refund_amount = consumption.process_refund("Audit trail testing refund")
refund_end = timezone.now()

consumption.refresh_from_db()
balance.refresh_from_db()

print(f"\nRefund Audit Trail:")
print(f"  Refund amount: {refund_amount}")
print(f"  Is refunded: {consumption.is_refunded}")
print(f"  Refund reason: '{consumption.refund_reason}'")
print(f"  Pre-refund updated_at: {pre_refund_updated}")
print(f"  Post-refund updated_at: {consumption.updated_at}")
print(f"  Refund processing time: {refund_end - refund_start}")

# Verify refund audit trail
assert consumption.is_refunded == True, "Refund flag should be set"
assert consumption.refund_reason == "Audit trail testing refund", "Refund reason should be recorded"
assert consumption.updated_at > pre_refund_updated, "Updated_at should advance after refund"
assert consumption.updated_at >= refund_start, "Refund timestamp should be within processing window"

# Verify balance audit trail
balance_change = pre_refund_balance - balance.hours_consumed
assert balance_change == refund_amount, "Balance change should match refund amount"

print("✓ Refund audit trail complete and accurate")
```

Expected: Refund processing creates complete audit trail with accurate timestamps
Screenshot: 04_refund_audit_trail.png

Step 5: Test Historical Data Integrity
Django Shell Commands:
```python
# Create multiple consumption records to test historical integrity
historical_data = []
balance_history = [balance.hours_consumed]

for i in range(5):
    # Create session
    hist_session = ClassSession.objects.create(
        teacher=teacher,
        school=school,
        date=date.today(),
        start_time=time(15 + i, 0),
        end_time=time(16 + i, 0),
        session_type='individual',
        grade_level='10',
        student_count=1,
        status='completed'
    )
    hist_session.students.add(student)
    
    # Create consumption
    hist_consumption = HourConsumption.objects.create(
        student_account=balance,
        class_session=hist_session,
        purchase_transaction=transaction,
        hours_consumed=Decimal(str(0.5 + (i * 0.1))),  # Varying amounts
        hours_originally_reserved=Decimal('1.00')
    )
    
    historical_data.append({
        'consumption': hist_consumption,
        'session': hist_session,
        'hours_consumed': hist_consumption.hours_consumed,
        'timestamp': hist_consumption.created_at,
    })
    
    balance.refresh_from_db()
    balance_history.append(balance.hours_consumed)
    
    time_module.sleep(0.1)  # Small delay to ensure timestamp ordering

print(f"\nHistorical Data Created:")
for i, data in enumerate(historical_data):
    print(f"  Record {i+1}: {data['hours_consumed']}h at {data['timestamp']}")

print(f"\nBalance History: {balance_history}")

# Verify chronological ordering
timestamps = [data['timestamp'] for data in historical_data]
assert timestamps == sorted(timestamps), "Timestamps should be chronologically ordered"

print("✓ Historical data maintains chronological integrity")
```

Expected: Historical data created with proper chronological ordering and balance tracking
Screenshot: 05_historical_data_integrity.png

Step 6: Test Cross-Model Audit Trail Integrity
Django Shell Commands:
```python
# Test audit trail across related models
print("\n=== Cross-Model Audit Trail Verification ===")

# Get all consumptions for the student
student_consumptions = HourConsumption.objects.filter(
    student_account=balance
).order_by('created_at')

print(f"Total consumptions for student: {student_consumptions.count()}")

# Verify each consumption has complete audit trail
for i, consumption in enumerate(student_consumptions):
    print(f"\nConsumption {i+1} Audit Trail:")
    print(f"  ID: {consumption.id}")
    print(f"  Created: {consumption.created_at}")
    print(f"  Updated: {consumption.updated_at}")
    print(f"  Consumed: {consumption.consumed_at}")
    print(f"  Hours: {consumption.hours_consumed}")
    print(f"  Refunded: {consumption.is_refunded}")
    
    # Verify related object integrity
    assert consumption.class_session is not None, f"Session missing for consumption {consumption.id}"
    assert consumption.purchase_transaction is not None, f"Transaction missing for consumption {consumption.id}"
    assert consumption.student_account == balance, f"Balance mismatch for consumption {consumption.id}"
    
    # Check session audit trail
    session = consumption.class_session
    print(f"  Session created: {session.created_at}")
    print(f"  Session updated: {session.updated_at}")
    
    # Check transaction audit trail
    trans = consumption.purchase_transaction
    print(f"  Transaction created: {trans.created_at}")
    print(f"  Transaction updated: {trans.updated_at}")

print("✓ Cross-model audit trail integrity verified")
```

Expected: All consumption records have complete audit trails with intact cross-model relationships
Screenshot: 06_cross_model_audit_integrity.png

Step 7: Test Data Integrity Under Concurrent Operations
Django Shell Commands:
```python
# Test data integrity with concurrent-like operations
import threading
from django.db import transaction

integrity_results = []
integrity_errors = []

def create_and_verify_consumption(thread_id):
    try:
        with transaction.atomic():
            # Create session
            thread_session = ClassSession.objects.create(
                teacher=teacher,
                school=school,
                date=date.today(),
                start_time=time(20 + thread_id, 0),
                end_time=time(21 + thread_id, 0),
                session_type='individual',
                grade_level='10',
                student_count=1,
                status='completed'
            )
            thread_session.students.add(student)
            
            # Record balance before
            balance.refresh_from_db()
            balance_before = balance.hours_consumed
            
            # Create consumption
            thread_consumption = HourConsumption.objects.create(
                student_account=balance,
                class_session=thread_session,
                purchase_transaction=transaction,
                hours_consumed=Decimal('0.25'),
                hours_originally_reserved=Decimal('1.00')
            )
            
            # Verify balance update
            balance.refresh_from_db()
            balance_after = balance.hours_consumed
            expected_balance = balance_before + Decimal('0.25')
            
            if balance_after == expected_balance:
                integrity_results.append(f"Thread {thread_id}: Balance update correct")
            else:
                integrity_errors.append(f"Thread {thread_id}: Balance inconsistency")
                
            # Verify audit trail
            if (thread_consumption.created_at and 
                thread_consumption.updated_at and 
                thread_consumption.consumed_at):
                integrity_results.append(f"Thread {thread_id}: Audit trail complete")
            else:
                integrity_errors.append(f"Thread {thread_id}: Audit trail incomplete")
                
    except Exception as e:
        integrity_errors.append(f"Thread {thread_id}: Exception - {e}")

# Run multiple threads
threads = []
for i in range(3):
    thread = threading.Thread(target=create_and_verify_consumption, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print(f"\nConcurrent Integrity Results:")
for result in integrity_results:
    print(f"  ✓ {result}")
for error in integrity_errors:
    print(f"  ⚠ {error}")

concurrent_success = len(integrity_errors) == 0
print(f"\nConcurrent operations integrity: {'PASS' if concurrent_success else 'FAIL'}")
```

Expected: Concurrent operations maintain data integrity and complete audit trails
Screenshot: 07_concurrent_integrity_test.png

Step 8: Test Audit Trail Query Performance
Django Shell Commands:
```python
# Test audit trail query performance and optimization
from django.db import connection

# Reset query tracking
connection.queries_log.clear()

# Perform comprehensive audit trail query
audit_query_start = timezone.now()

audit_data = HourConsumption.objects.select_related(
    'student_account__student',
    'class_session__teacher__user',
    'purchase_transaction'
).prefetch_related(
    'class_session__students'
).filter(
    student_account=balance
).order_by('-created_at')

# Access audit trail data
audit_records = []
for consumption in audit_data:
    audit_record = {
        'id': consumption.id,
        'student': consumption.student_account.student.name,
        'teacher': consumption.class_session.teacher.user.name,
        'hours': consumption.hours_consumed,
        'created': consumption.created_at,
        'refunded': consumption.is_refunded,
        'transaction_amount': consumption.purchase_transaction.amount,
    }
    audit_records.append(audit_record)

audit_query_end = timezone.now()
query_time = (audit_query_end - audit_query_start).total_seconds()
query_count = len(connection.queries)

print(f"\nAudit Trail Query Performance:")
print(f"  Records retrieved: {len(audit_records)}")
print(f"  Query time: {query_time:.3f} seconds")
print(f"  SQL queries executed: {query_count}")
print(f"  Queries per record: {query_count / len(audit_records) if audit_records else 'N/A'}")

# Display sample audit records
print(f"\nSample Audit Records:")
for i, record in enumerate(audit_records[:3]):
    print(f"  Record {i+1}:")
    for key, value in record.items():
        print(f"    {key}: {value}")

performance_acceptable = query_time < 1.0 and query_count < 10
print(f"\nQuery performance: {'ACCEPTABLE' if performance_acceptable else 'NEEDS_OPTIMIZATION'}")
```

Expected: Audit trail queries perform efficiently with optimized database access
Screenshot: 08_audit_query_performance.png

Step 9: Test Data Integrity Validation Rules
Django Shell Commands:
```python
# Test comprehensive data integrity validation
print("\n=== Data Integrity Validation Tests ===")

validation_tests = []

# Test 1: Referential integrity
try:
    # Create consumption with valid references
    valid_session = ClassSession.objects.create(
        teacher=teacher,
        school=school,
        date=date.today(),
        start_time=time(12, 0),
        end_time=time(13, 0),
        session_type='individual',
        grade_level='10',
        student_count=1,
        status='completed'
    )
    valid_session.students.add(student)
    
    valid_consumption = HourConsumption.objects.create(
        student_account=balance,
        class_session=valid_session,
        purchase_transaction=transaction,
        hours_consumed=Decimal('1.00'),
        hours_originally_reserved=Decimal('1.00')
    )
    validation_tests.append("✓ Valid references accepted")
except Exception as e:
    validation_tests.append(f"⚠ Valid reference test failed: {e}")

# Test 2: Cascade behavior verification
try:
    consumption_to_delete = HourConsumption.objects.filter(
        student_account=balance
    ).last()
    
    if consumption_to_delete:
        session_id = consumption_to_delete.class_session.id
        consumption_to_delete.delete()
        
        # Session should still exist after consumption deletion
        session_still_exists = ClassSession.objects.filter(id=session_id).exists()
        if session_still_exists:
            validation_tests.append("✓ Cascade behavior correct (session preserved)")
        else:
            validation_tests.append("⚠ Unexpected cascade deletion")
    else:
        validation_tests.append("⚠ No consumption available for cascade test")
        
except Exception as e:
    validation_tests.append(f"⚠ Cascade test error: {e}")

# Test 3: Balance calculation integrity
try:
    # Recalculate balance manually
    all_student_consumptions = HourConsumption.objects.filter(student_account=balance)
    manual_consumed = sum(c.hours_consumed for c in all_student_consumptions)
    manual_refunded = sum(c.hours_difference for c in all_student_consumptions.filter(is_refunded=True))
    expected_consumed = manual_consumed - manual_refunded
    
    balance.refresh_from_db()
    actual_consumed = balance.hours_consumed
    
    if abs(actual_consumed - expected_consumed) < Decimal('0.001'):
        validation_tests.append("✓ Balance calculation integrity verified")
    else:
        validation_tests.append(f"⚠ Balance calculation mismatch: {actual_consumed} vs {expected_consumed}")
        
except Exception as e:
    validation_tests.append(f"⚠ Balance calculation test error: {e}")

print("\nData Integrity Validation Results:")
for test_result in validation_tests:
    print(f"  {test_result}")
```

Expected: All data integrity validation rules enforced correctly
Screenshot: 09_data_integrity_validation.png

Step 10: Test Audit Log Completeness
Django Shell Commands:
```python
# Test completeness of audit logging
print("\n=== Audit Log Completeness Verification ===")

# Get all operations performed during this test
test_consumptions = HourConsumption.objects.filter(
    class_session__date=date.today(),
    created_at__gte=creation_start
).order_by('created_at')

audit_completeness = {
    'total_records': test_consumptions.count(),
    'records_with_timestamps': 0,
    'records_with_relationships': 0,
    'refunded_records': 0,
    'refund_audit_complete': 0,
}

for consumption in test_consumptions:
    # Check timestamp completeness
    if (consumption.created_at and consumption.updated_at and consumption.consumed_at):
        audit_completeness['records_with_timestamps'] += 1
    
    # Check relationship completeness
    if (consumption.student_account and consumption.class_session and consumption.purchase_transaction):
        audit_completeness['records_with_relationships'] += 1
    
    # Check refund audit completeness
    if consumption.is_refunded:
        audit_completeness['refunded_records'] += 1
        if consumption.refund_reason:
            audit_completeness['refund_audit_complete'] += 1

print("Audit Log Completeness Analysis:")
for metric, value in audit_completeness.items():
    if metric == 'total_records':
        print(f"  {metric}: {value}")
    else:
        percentage = (value / audit_completeness['total_records'] * 100) if audit_completeness['total_records'] > 0 else 0
        print(f"  {metric}: {value}/{audit_completeness['total_records']} ({percentage:.1f}%)")

# Check for any records missing critical audit information
incomplete_records = test_consumptions.filter(
    models.Q(created_at__isnull=True) | 
    models.Q(updated_at__isnull=True) | 
    models.Q(consumed_at__isnull=True)
)

if incomplete_records.exists():
    print(f"⚠ Found {incomplete_records.count()} records with incomplete timestamps")
else:
    print("✓ All records have complete timestamp audit trail")

completeness_score = (
    audit_completeness['records_with_timestamps'] + 
    audit_completeness['records_with_relationships']
) / (audit_completeness['total_records'] * 2) if audit_completeness['total_records'] > 0 else 0

print(f"\nOverall audit completeness score: {completeness_score:.2%}")
```

Expected: All audit logs complete with no missing critical information
Screenshot: 10_audit_log_completeness.png

Step 11: Test Long-Term Audit Trail Retention
Django Shell Commands:
```python
# Test audit trail behavior over extended time periods
print("\n=== Long-Term Audit Trail Retention Test ===")

# Simulate historical data by creating records with backdated timestamps
from django.utils import timezone
import django.utils.timezone

# Create consumption records spanning different time periods
time_periods = [
    timezone.now() - timedelta(days=30),   # 1 month ago
    timezone.now() - timedelta(days=7),    # 1 week ago
    timezone.now() - timedelta(days=1),    # 1 day ago
    timezone.now(),                        # Now
]

historical_consumptions = []

for i, timestamp in enumerate(time_periods):
    hist_session = ClassSession.objects.create(
        teacher=teacher,
        school=school,
        date=date.today(),
        start_time=time(8 + i, 0),
        end_time=time(9 + i, 0),
        session_type='individual',
        grade_level='10',
        student_count=1,
        status='completed'
    )
    hist_session.students.add(student)
    
    hist_consumption = HourConsumption.objects.create(
        student_account=balance,
        class_session=hist_session,
        purchase_transaction=transaction,
        hours_consumed=Decimal('1.00'),
        hours_originally_reserved=Decimal('1.00')
    )
    
    # Manually set timestamps to simulate historical data
    HourConsumption.objects.filter(id=hist_consumption.id).update(
        created_at=timestamp,
        updated_at=timestamp,
        consumed_at=timestamp
    )
    
    hist_consumption.refresh_from_db()
    historical_consumptions.append(hist_consumption)

print("Historical Audit Trail Created:")
for i, consumption in enumerate(historical_consumptions):
    print(f"  Period {i+1}: {consumption.created_at} - {consumption.hours_consumed}h")

# Test audit trail queries across time periods
recent_consumptions = HourConsumption.objects.filter(
    student_account=balance,
    created_at__gte=timezone.now() - timedelta(days=7)
).count()

old_consumptions = HourConsumption.objects.filter(
    student_account=balance,
    created_at__lt=timezone.now() - timedelta(days=7)
).count()

print(f"\nAudit Trail Retention Analysis:")
print(f"  Recent consumptions (last 7 days): {recent_consumptions}")
print(f"  Historical consumptions (older than 7 days): {old_consumptions}")
print(f"  Total audit trail coverage: {recent_consumptions + old_consumptions}")

# Verify data integrity across time periods
integrity_check = True
for consumption in historical_consumptions:
    if not (consumption.created_at and consumption.updated_at and consumption.consumed_at):
        integrity_check = False
        print(f"⚠ Incomplete timestamps for consumption {consumption.id}")

if integrity_check:
    print("✓ Long-term audit trail integrity maintained")
else:
    print("⚠ Long-term audit trail has integrity issues")
```

Expected: Audit trail maintains integrity across extended time periods
Screenshot: 11_longterm_audit_retention.png

Step 12: Test Audit Trail Export and Reporting
Django Shell Commands:
```python
# Test audit trail data export capabilities
print("\n=== Audit Trail Export and Reporting Test ===")

# Generate comprehensive audit report
audit_report = {
    'report_generated': timezone.now(),
    'student_id': student.id,
    'student_name': student.name,
    'total_consumptions': 0,
    'total_hours_consumed': Decimal('0.00'),
    'total_hours_refunded': Decimal('0.00'),
    'consumption_details': [],
}

student_consumptions = HourConsumption.objects.filter(
    student_account=balance
).select_related(
    'class_session__teacher__user',
    'purchase_transaction'
).order_by('-created_at')

for consumption in student_consumptions:
    consumption_detail = {
        'id': consumption.id,
        'date': consumption.class_session.date.isoformat(),
        'teacher': consumption.class_session.teacher.user.name,
        'hours_consumed': float(consumption.hours_consumed),
        'hours_reserved': float(consumption.hours_originally_reserved),
        'hours_difference': float(consumption.hours_difference),
        'is_refunded': consumption.is_refunded,
        'refund_reason': consumption.refund_reason,
        'transaction_amount': float(consumption.purchase_transaction.amount),
        'created_at': consumption.created_at.isoformat(),
        'updated_at': consumption.updated_at.isoformat(),
    }
    
    audit_report['consumption_details'].append(consumption_detail)
    audit_report['total_hours_consumed'] += consumption.hours_consumed
    
    if consumption.is_refunded:
        audit_report['total_hours_refunded'] += consumption.hours_difference

audit_report['total_consumptions'] = len(audit_report['consumption_details'])

print("Audit Report Summary:")
print(f"  Report generated: {audit_report['report_generated']}")
print(f"  Student: {audit_report['student_name']}")
print(f"  Total consumptions: {audit_report['total_consumptions']}")
print(f"  Total hours consumed: {audit_report['total_hours_consumed']}")
print(f"  Total hours refunded: {audit_report['total_hours_refunded']}")

# Test export format compatibility
import json
try:
    # Convert to JSON for export
    json_report = json.dumps(audit_report, default=str, indent=2)
    print(f"✓ Audit report JSON export: {len(json_report)} characters")
except Exception as e:
    print(f"⚠ JSON export error: {e}")

# Sample detailed records
print(f"\nSample Audit Records (first 3):")
for i, detail in enumerate(audit_report['consumption_details'][:3]):
    print(f"  Record {i+1}:")
    for key, value in detail.items():
        print(f"    {key}: {value}")
```

Expected: Audit trail data can be exported in standard formats for reporting
Screenshot: 12_audit_export_reporting.png

Step 13: Test Data Recovery and Backup Integrity
Django Shell Commands:
```python
# Test data recovery scenarios and backup integrity
print("\n=== Data Recovery and Backup Integrity Test ===")

# Create backup of current state
backup_data = {
    'consumptions': [],
    'balance_state': {
        'hours_consumed': balance.hours_consumed,
        'hours_purchased': balance.hours_purchased,
        'balance_amount': balance.balance_amount,
    },
    'backup_timestamp': timezone.now(),
}

# Backup all consumption records
for consumption in HourConsumption.objects.filter(student_account=balance):
    backup_record = {
        'id': consumption.id,
        'hours_consumed': consumption.hours_consumed,
        'hours_originally_reserved': consumption.hours_originally_reserved,
        'is_refunded': consumption.is_refunded,
        'refund_reason': consumption.refund_reason,
        'created_at': consumption.created_at,
        'updated_at': consumption.updated_at,
        'consumed_at': consumption.consumed_at,
        'session_id': consumption.class_session.id,
        'transaction_id': consumption.purchase_transaction.id,
    }
    backup_data['consumptions'].append(backup_record)

print(f"Backup created with {len(backup_data['consumptions'])} consumption records")

# Simulate data recovery verification
recovery_successful = True

# Verify each backed up record still exists and matches
for backup_record in backup_data['consumptions']:
    try:
        current_record = HourConsumption.objects.get(id=backup_record['id'])
        
        # Verify critical fields match
        if (current_record.hours_consumed != backup_record['hours_consumed'] or
            current_record.is_refunded != backup_record['is_refunded'] or
            current_record.created_at != backup_record['created_at']):
            print(f"⚠ Data integrity issue with record {backup_record['id']}")
            recovery_successful = False
            
    except HourConsumption.DoesNotExist:
        print(f"⚠ Record {backup_record['id']} missing during recovery check")
        recovery_successful = False

# Verify balance state integrity
balance.refresh_from_db()
if (balance.hours_consumed == backup_data['balance_state']['hours_consumed'] and
    balance.hours_purchased == backup_data['balance_state']['hours_purchased']):
    print("✓ Balance state matches backup")
else:
    print("⚠ Balance state diverged from backup")
    recovery_successful = False

print(f"\nData recovery integrity: {'PASS' if recovery_successful else 'FAIL'}")

# Test audit trail reconstruction capability
reconstructed_balance = Decimal('0.00')
for consumption in HourConsumption.objects.filter(student_account=balance):
    reconstructed_balance += consumption.hours_consumed
    if consumption.is_refunded:
        reconstructed_balance -= consumption.hours_difference

balance_difference = abs(balance.hours_consumed - reconstructed_balance)
if balance_difference < Decimal('0.001'):
    print("✓ Audit trail allows accurate balance reconstruction")
else:
    print(f"⚠ Balance reconstruction discrepancy: {balance_difference}")
```

Expected: Data recovery procedures maintain integrity and allow accurate reconstruction
Screenshot: 13_data_recovery_integrity.png

Step 14: Test Audit Trail Compliance and Standards
Django Shell Commands:
```python
# Test audit trail compliance with standard requirements
print("\n=== Audit Trail Compliance Verification ===")

compliance_checks = {
    'immutable_history': True,
    'complete_timestamps': True,
    'traceable_changes': True,
    'user_attribution': True,
    'data_integrity': True,
    'retention_policy': True,
}

# Check immutable history (original timestamps preserved)
original_consumption = HourConsumption.objects.filter(student_account=balance).first()
if original_consumption:
    original_created = original_consumption.created_at
    
    # Update record
    original_consumption.save()
    original_consumption.refresh_from_db()
    
    if original_consumption.created_at == original_created:
        print("✓ Immutable history: Original timestamps preserved")
    else:
        print("⚠ Immutable history: Original timestamps modified")
        compliance_checks['immutable_history'] = False

# Check complete timestamps
incomplete_timestamps = HourConsumption.objects.filter(
    student_account=balance
).filter(
    models.Q(created_at__isnull=True) | 
    models.Q(updated_at__isnull=True) | 
    models.Q(consumed_at__isnull=True)
).count()

if incomplete_timestamps == 0:
    print("✓ Complete timestamps: All records have full timestamp data")
else:
    print(f"⚠ Complete timestamps: {incomplete_timestamps} records missing timestamps")
    compliance_checks['complete_timestamps'] = False

# Check traceable changes (refund audit trail)
refunded_consumptions = HourConsumption.objects.filter(
    student_account=balance,
    is_refunded=True
)

traceable_refunds = refunded_consumptions.filter(
    refund_reason__isnull=False,
    refund_reason__gt=''
).count()

if traceable_refunds == refunded_consumptions.count():
    print("✓ Traceable changes: All refunds have documented reasons")
else:
    print(f"⚠ Traceable changes: {refunded_consumptions.count() - traceable_refunds} refunds lack reasons")
    compliance_checks['traceable_changes'] = False

# Check data integrity consistency
consistency_errors = 0
for consumption in HourConsumption.objects.filter(student_account=balance):
    # Verify hours_difference calculation
    calculated_difference = consumption.hours_originally_reserved - consumption.hours_consumed
    if consumption.hours_difference != calculated_difference:
        consistency_errors += 1

if consistency_errors == 0:
    print("✓ Data integrity: All calculations consistent")
else:
    print(f"⚠ Data integrity: {consistency_errors} calculation inconsistencies")
    compliance_checks['data_integrity'] = False

# Check user attribution (via related models)
consumptions_with_attribution = HourConsumption.objects.filter(
    student_account=balance,
    class_session__teacher__isnull=False,
    student_account__student__isnull=False
).count()

total_consumptions = HourConsumption.objects.filter(student_account=balance).count()

if consumptions_with_attribution == total_consumptions:
    print("✓ User attribution: All operations traceable to users")
else:
    print(f"⚠ User attribution: {total_consumptions - consumptions_with_attribution} operations lack attribution")
    compliance_checks['user_attribution'] = False

# Compliance summary
compliance_score = sum(compliance_checks.values()) / len(compliance_checks)
print(f"\nCompliance Summary:")
for check, passed in compliance_checks.items():
    status = "PASS" if passed else "FAIL"
    print(f"  {check}: {status}")

print(f"\nOverall compliance score: {compliance_score:.1%}")
```

Expected: Audit trail meets compliance standards for data integrity and traceability
Screenshot: 14_compliance_verification.png

Step 15: Final Audit Trail and Data Integrity Summary
Django Shell Commands:
```python
# Final comprehensive verification and summary
print("\n=== FINAL AUDIT TRAIL AND DATA INTEGRITY SUMMARY ===")

# Get final state
final_counts = {
    'consumptions': HourConsumption.objects.count(),
    'sessions': ClassSession.objects.count(),
    'balances': StudentAccountBalance.objects.count(),
    'transactions': PurchaseTransaction.objects.count(),
}

# Calculate test impact
test_impact = {
    'consumptions_created': final_counts['consumptions'] - initial_counts['consumptions'],
    'sessions_created': final_counts['sessions'] - initial_counts['sessions'],
    'balances_created': final_counts['balances'] - initial_counts['balances'],
    'transactions_created': final_counts['transactions'] - initial_counts['transactions'],
}

print("Test Impact Summary:")
for model, created in test_impact.items():
    print(f"  {model}: +{created}")

# Final data integrity verification
final_verification = {
    'audit_trail_complete': True,
    'timestamps_accurate': True,
    'balances_consistent': True,
    'relationships_intact': True,
}

# Verify audit trail completeness
test_consumptions = HourConsumption.objects.filter(
    created_at__gte=creation_start
)

for consumption in test_consumptions:
    if not (consumption.created_at and consumption.updated_at and consumption.consumed_at):
        final_verification['audit_trail_complete'] = False
    
    if not (consumption.student_account and consumption.class_session and consumption.purchase_transaction):
        final_verification['relationships_intact'] = False

# Verify balance consistency
for test_balance in StudentAccountBalance.objects.all():
    balance_consumptions = HourConsumption.objects.filter(student_account=test_balance)
    calculated_consumed = sum(c.hours_consumed for c in balance_consumptions)
    calculated_refunded = sum(c.hours_difference for c in balance_consumptions.filter(is_refunded=True))
    expected_consumed = calculated_consumed - calculated_refunded
    
    if abs(test_balance.hours_consumed - expected_consumed) > Decimal('0.001'):
        final_verification['balances_consistent'] = False

print("\nFinal Verification Results:")
for check, passed in final_verification.items():
    status = "✓ PASS" if passed else "⚠ FAIL"
    print(f"  {check}: {status}")

# Test completion summary
test_end_time = timezone.now()
test_duration = test_end_time - creation_start

print(f"\nTest Execution Summary:")
print(f"  Start time: {creation_start}")
print(f"  End time: {test_end_time}")
print(f"  Duration: {test_duration}")
print(f"  Records created during test: {test_impact['consumptions_created']}")

overall_success = all(final_verification.values())
print(f"\nOVERALL AUDIT TRAIL AND DATA INTEGRITY TEST: {'PASS' if overall_success else 'FAIL'}")
```

Expected: Complete audit trail functionality verified with all data integrity checks passing
Screenshot: 15_final_audit_summary.png

=== PASS/FAIL CRITERIA ===

PASS: Complete audit trail functionality works correctly with data integrity maintained across all operations
FAIL: Any audit trail component fails or data integrity compromised

Individual Step Criteria:
- Step 1-2: PASS if timestamp accuracy verified, FAIL if timing inconsistencies
- Step 3-4: PASS if update and refund audit trails complete, FAIL if missing information
- Step 5-6: PASS if historical data and cross-model integrity maintained, FAIL if corruption
- Step 7-8: PASS if concurrent operations and query performance acceptable, FAIL if integrity issues
- Step 9-10: PASS if validation rules and audit completeness verified, FAIL if gaps found
- Step 11-12: PASS if long-term retention and export capabilities work, FAIL if data loss
- Step 13-14: PASS if recovery integrity and compliance verified, FAIL if standards not met
- Step 15: PASS if final verification complete, FAIL if any integrity check fails

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== VALIDATION CHECKPOINTS ===

Audit Trail Verification:
- Complete timestamp tracking (created_at, updated_at, consumed_at)
- Refund audit trail with reasons and timestamps
- Historical data preservation and chronological ordering
- Cross-model relationship audit integrity

Data Integrity Verification:
- Balance calculations consistent across all operations
- Referential integrity maintained between related models
- Concurrent operations handled safely with proper isolation
- Transaction rollback prevents partial updates

Compliance Verification:
- Immutable history with preserved original timestamps
- Complete traceability of all changes and operations
- User attribution through related model relationships
- Export capabilities for reporting and backup purposes