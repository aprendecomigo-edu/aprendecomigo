QA Test Case: Multi-Role User Authentication

Test ID: PERM-001
Test Name: Multi-Role User Authentication and Dashboard
Purpose: Verify that a user with multiple roles across different schools can authenticate successfully and see appropriate dashboard content based on their primary role
Expected Result: User successfully logs in and dashboard displays correct information reflecting their multiple roles

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Testing Focus: Complex permissions with one user having multiple roles across different schools

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Data Requirements:
- Main Test User: test.manager@example.com
  - Role 1: school_owner at "Test School"
  - Role 2: teacher at "Test School 2"
  - Role 3: student at "Test School 3"
- Supporting Schools and Users (created by setup command)
- All users must be email verified for login

Database State:
- Test data must be set up using the setup_permissions_test_data management command
- Educational system (Portugal) must exist
- All school memberships must be active

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment and Data Setup
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  cd backend
  python manage.py setup_permissions_test_data --clean

Expected: Management command creates test data successfully without errors
Screenshot: 01_test_data_setup.png

Step 2: Start Backend Server
Commands:
  python manage.py runserver 8000 > /tmp/django_server.log 2>&1 &
  echo "Backend server started on port 8000"

Expected: Django development server starts successfully
Verify: Backend accessible at http://localhost:8000/api/

Step 3: Start Frontend Development Server
Commands:
  cd ../frontend-ui
  npm run web:dev > /tmp/expo_output.log 2>&1 &
  sleep 10
  echo "Frontend server should be running"

Expected: Expo development server starts successfully
Verify: Frontend accessible at http://localhost:8081

Step 4: Open Application and Navigate to Login
1. Open browser and navigate to http://localhost:8081
2. Verify the application loads correctly
3. Look for sign-in page or login form

Expected: Application loads and displays login interface
Screenshot: 02_login_page_loaded.png

Step 5: Attempt Login with Multi-Role User
1. Enter email: test.manager@example.com
2. Click "Send Code" or equivalent login button
3. Wait for verification code to be "sent" (check backend logs)

Expected: Login request is processed and verification code generation is triggered
Screenshot: 03_verification_code_requested.png

Step 6: Verify Code Generation (Backend Check)
Commands:
  # Check Django logs for verification code
  tail -20 /tmp/django_server.log | grep -i "verification\|code" || echo "No verification logs found"

Expected: Backend logs show verification code was generated for test.manager@example.com
Note: In development, codes are logged to console

Step 7: Extract and Enter Verification Code
1. From backend logs or database, get the current verification code
2. Enter the 6-digit verification code in the frontend
3. Submit the verification form

Expected: Authentication succeeds and user is logged in
Screenshot: 04_successful_authentication.png

Step 8: Verify Dashboard Content and Multi-Role Display
1. Check that dashboard loads successfully
2. Look for indication of multiple roles/schools
3. Verify user information displays correctly
4. Check for role-specific navigation or content

Expected: Dashboard shows:
- User name: "Multi Role Test Manager"
- Multiple school memberships visible
- Role-specific navigation or context switcher
- Appropriate permissions indicators

Screenshot: 05_dashboard_multi_role_view.png

Step 9: Verify Role Information in User Profile/Settings
1. Navigate to user profile or account settings
2. Look for list of roles and schools
3. Verify all three roles are displayed:
   - School Owner at "Test School"
   - Teacher at "Test School 2"
   - Student at "Test School 3"

Expected: All three roles and school memberships are visible
Screenshot: 06_user_roles_profile_view.png

Step 10: Test Navigation Between School Contexts (if available)
1. Look for school selector or context switcher
2. If available, try switching between different school contexts
3. Verify that switching changes available options/navigation

Expected: User can switch between school contexts or at minimum see all their roles
Screenshot: 07_school_context_switching.png

=== PASS/FAIL CRITERIA ===

PASS: User successfully logs in AND dashboard displays multiple roles AND no authentication errors occur
FAIL: Login fails OR dashboard doesn't load OR roles are not displayed correctly OR any authentication errors

Individual Step Criteria:
- Step 1: PASS if test data created without errors, FAIL if command errors or data incomplete
- Step 2: PASS if backend starts on port 8000, FAIL if server doesn't start or errors
- Step 3: PASS if frontend accessible at :8081, FAIL if frontend doesn't load
- Step 4: PASS if login page displays, FAIL if app doesn't load or no login interface
- Step 5: PASS if code request processed, FAIL if login form errors or no response
- Step 6: PASS if verification code generated in logs, FAIL if no code or errors
- Step 7: PASS if authentication succeeds, FAIL if code rejected or login fails
- Step 8: PASS if dashboard shows multi-role info, FAIL if basic dashboard or errors
- Step 9: PASS if profile shows all 3 roles, FAIL if roles missing or incorrect
- Step 10: PASS if context switching works or roles clearly visible, FAIL if functionality broken

Overall Result: PASS only if ALL steps pass AND user can successfully authenticate with multi-role access
Special Failure Conditions:
- Any authentication failures = FAIL
- Missing role information = FAIL
- Dashboard not reflecting multi-role status = FAIL
- Backend errors during authentication = FAIL

=== POST-TEST CLEANUP ===

Commands to stop servers:
  pkill -f "python manage.py runserver"
  pkill -f "npm run web:dev"

Verify cleanup:
  ps aux | grep -E "(runserver|npm.*web:dev)" | grep -v grep
