TEST_ID: payment-001
TEST_NAME: Payment Intent Creation
PURPOSE: Validate PaymentService create_payment_intent method with comprehensive package and subscription purchase scenarios

ENVIRONMENT_SETUP:
- Django development server running on localhost:8000
- Frontend server running on localhost:8081
- Test Stripe API keys configured in environment
- PostgreSQL or SQLite database available
- Valid .env file with Stripe configuration
- PaymentService available with full StripeService integration

PRE_CONDITIONS:
- Development servers are stopped initially
- Environment variables are properly configured
- Test Stripe keys (sk_test_, pk_test_) are available
- User authentication system is functional
- Test student user account exists
- Database models (PurchaseTransaction, StudentAccountBalance) are migrated
- PaymentService is properly integrated with StripeService

TEST_STEPS:

1. ENVIRONMENT_SETUP_AND_STARTUP
   - Navigate to project root: cd /Users/anapmc/Code/aprendecomigo
   - Activate virtual environment: source .venv/bin/activate
   - Start development servers: make dev
   - Wait for both Django and Expo servers to be ready
   - Verify no startup errors in logs
   - Screenshot: Server startup success

2. DJANGO_SHELL_SETUP
   - Open Django shell: python manage.py shell
   - Import required models and services:
     * from accounts.models import CustomUser
     * from finances.services.payment_service import PaymentService
     * from finances.models import PurchaseTransaction, StudentAccountBalance
   - Initialize PaymentService: service = PaymentService()
   - Get test student user: student = CustomUser.objects.filter(role='student').first()
   - If no student exists, create one: student = CustomUser.objects.create_user(email='test@student.com', name='Test Student', role='student')
   - Screenshot: Django shell setup complete

3. PACKAGE_PAYMENT_INTENT_CREATION
   - Test package purchase with valid metadata:
     * pricing_plan_id = "package_10_hours"
     * metadata = {"amount": "99.99", "hours": "10", "package_name": "10 Hour Package"}
     * result = service.create_payment_intent(student, pricing_plan_id, metadata)
   - Verify result['success'] is True
   - Verify result contains 'client_secret', 'transaction_id', 'payment_intent_id'
   - Check client_secret starts with 'pi_' and ends with '_secret_'
   - Verify transaction_id is a valid integer
   - Screenshot: Package payment intent creation success

4. SUBSCRIPTION_PAYMENT_INTENT_CREATION
   - Test subscription purchase with billing metadata:
     * pricing_plan_id = "monthly_subscription"
     * metadata = {"amount": "29.99", "subscription_name": "Monthly Tutoring", "billing_cycle": "monthly"}
     * result = service.create_payment_intent(student, pricing_plan_id, metadata)
   - Verify result['success'] is True
   - Verify result contains required fields (client_secret, transaction_id, payment_intent_id)
   - Check transaction was created with subscription type in database
   - Screenshot: Subscription payment intent creation success

5. DATABASE_TRANSACTION_VERIFICATION
   - Get created transaction: transaction = PurchaseTransaction.objects.get(id=result['transaction_id'])
   - Verify transaction.student equals the test student
   - Verify transaction.payment_status is 'processing'
   - Verify transaction.stripe_payment_intent_id matches result['payment_intent_id']
   - Verify transaction.amount equals Decimal from metadata
   - Verify transaction.metadata contains the original metadata
   - For package: verify transaction.expires_at is set to ~1 year from now
   - For subscription: verify transaction.expires_at is None
   - Screenshot: Database transaction verification

6. STRIPE_PAYMENT_INTENT_VERIFICATION
   - Import stripe: import stripe
   - Retrieve from Stripe: pi = stripe.PaymentIntent.retrieve(result['payment_intent_id'])
   - Verify pi.amount equals amount in cents (amount * 100)
   - Verify pi.currency equals 'eur'
   - Verify pi.status equals 'requires_payment_method'
   - Verify pi.metadata contains user_id, pricing_plan_id, transaction_type
   - Verify pi.metadata contains custom metadata fields with 'custom_' prefix
   - Screenshot: Stripe payment intent verification

7. INPUT_VALIDATION_TESTING
   - Test missing amount in metadata:
     * result = service.create_payment_intent(student, "test_plan", {})
     * Verify result['success'] is False
     * Verify result['error_type'] is 'validation_error'
     * Verify result['message'] contains 'Amount is required'
   - Test invalid amount formats:
     * result = service.create_payment_intent(student, "test_plan", {"amount": "invalid"})
     * Verify result['success'] is False and error_type is 'validation_error'
   - Test negative amount:
     * result = service.create_payment_intent(student, "test_plan", {"amount": "-10.00"})
     * Verify result['success'] is False and error_type is 'validation_error'
   - Screenshot: Input validation testing

8. TRANSACTION_TYPE_DETECTION_TESTING
   - Test explicit subscription detection via metadata:
     * metadata = {"amount": "19.99", "subscription_name": "Basic Plan"}
     * result = service.create_payment_intent(student, "basic_plan", metadata)
     * transaction = PurchaseTransaction.objects.get(id=result['transaction_id'])
     * Verify transaction.transaction_type is 'subscription'
   - Test subscription detection via pricing_plan_id:
     * metadata = {"amount": "19.99"}
     * result = service.create_payment_intent(student, "monthly_subscription_plan", metadata)
     * transaction = PurchaseTransaction.objects.get(id=result['transaction_id'])
     * Verify transaction.transaction_type is 'subscription'
   - Test default package type:
     * metadata = {"amount": "49.99"}
     * result = service.create_payment_intent(student, "custom_plan", metadata)
     * transaction = PurchaseTransaction.objects.get(id=result['transaction_id'])
     * Verify transaction.transaction_type is 'package'
   - Screenshot: Transaction type detection testing

9. ERROR_HANDLING_TESTING
   - Test Stripe error simulation (invalid amount):
     * metadata = {"amount": "0.01"}  # Below minimum for EUR
     * result = service.create_payment_intent(student, "test_plan", metadata)
     * Verify result['success'] is False
     * Verify result contains appropriate error_type and message
   - Test with invalid user (None):
     * result = service.create_payment_intent(None, "test_plan", {"amount": "10.00"})
     * Verify result['success'] is False or appropriate exception handling
   - Screenshot: Error handling testing

10. ATOMIC_TRANSACTION_TESTING
    - Count initial transactions: initial_count = PurchaseTransaction.objects.count()
    - Test atomic failure scenario by temporarily corrupting database connection
    - Verify no partial transactions are created on failure
    - Verify transaction count remains at initial_count after failure
    - Test successful atomic creation restores proper behavior
    - Screenshot: Atomic transaction testing

EXPECTED_RESULTS:
- Payment intents are created successfully for both packages and subscriptions
- Database transactions are created atomically with correct data
- Stripe payment intents are properly configured with metadata
- Input validation prevents invalid data from creating payment intents
- Transaction type detection works correctly based on metadata and plan ID
- Error handling provides appropriate feedback without exposing sensitive data
- Atomic transactions ensure data consistency

PASS_CRITERIA:
✅ Package payment intents created successfully with correct metadata
✅ Subscription payment intents created successfully with billing info
✅ Database transactions created atomically with all required fields
✅ Stripe payment intents created with proper amount, currency, and metadata
✅ Input validation rejects invalid amounts and missing required fields
✅ Transaction type detection works for packages and subscriptions
✅ Error handling provides user-friendly messages without sensitive data
✅ Atomic transactions maintain data consistency
✅ No sensitive information exposed in responses or logs
✅ All business logic (expiration, metadata) handled correctly

FAIL_CRITERIA:
❌ Payment intent creation fails with valid input data
❌ Database transactions not created or contain incorrect data
❌ Stripe payment intents missing required fields or metadata
❌ Input validation allows invalid data through
❌ Transaction type detection assigns incorrect types
❌ Error handling exposes sensitive information or stack traces
❌ Atomic transaction failures leave partial data
❌ Business logic not applied correctly (expiration dates, etc.)
❌ Security vulnerabilities in metadata handling
❌ Performance issues with payment intent creation

FILES_TO_VERIFY:
- backend/finances/services/payment_service.py (PaymentService implementation)
- backend/finances/services/stripe_base.py (StripeService integration)
- backend/finances/models.py (PurchaseTransaction and related models)
- backend/finances/views.py (API endpoints for payments)
- backend/aprendecomigo/settings/base.py (Stripe configuration)

SCREENSHOTS_REQUIRED:
1. Server startup success
2. Django shell setup complete
3. Package payment intent creation success
4. Subscription payment intent creation success
5. Database transaction verification
6. Stripe payment intent verification
7. Input validation testing
8. Transaction type detection testing
9. Error handling testing
10. Atomic transaction testing