QA Test Case: Integration Testing - API-Frontend and Database Consistency

Test ID: PRICING-006
Test Name: Integration Testing for Pricing Plan System
Purpose: Verify complete integration between Django Admin, API endpoint, database consistency, caching, and frontend compatibility
Expected Result: All system components work together seamlessly with data consistency and proper performance

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Component: Complete pricing plan system integration
- Implementation: GitHub Issue #29 - Product Pricing Configuration Model
- Integration Points: Admin → Database → API → Cache → Frontend

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Focus Areas:
- End-to-end data flow consistency
- Admin changes reflected in API
- Cache invalidation and updates
- Database integrity across operations
- Performance under realistic load
- Frontend integration compatibility

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Initial State
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Establish clean initial state:
```bash
cd backend
python manage.py shell -c "
from finances.models import PricingPlan
from django.core.cache import cache
# Clear existing plans and cache
PricingPlan.objects.all().delete()
cache.clear()
print('Cleared plans and cache for integration testing')
"
```

Expected: Clean state for comprehensive integration testing
Screenshot: 01_clean_initial_state.png

Step 2: Create Test Data via Management Command
Use management command to create baseline data:
```bash
python manage.py create_default_pricing_plans --verbosity=1
```

Verify data creation:
```bash
python manage.py shell -c "
from finances.models import PricingPlan
print(f'Plans created: {PricingPlan.objects.count()}')
for plan in PricingPlan.objects.all()[:3]:
    print(f'  {plan.name}: €{plan.price_eur}')
"
```

Expected: 7 default plans created successfully

Step 3: Test API Endpoint Returns Correct Data
Verify API returns the created plans:
```bash
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
print(f'API returned {len(data)} plans')
for plan in data[:3]:
    print(f'  {plan[\"name\"]}: €{plan[\"price_eur\"]} ({plan[\"plan_type\"]})')
"
```

Expected: API returns all 7 plans with correct data

Step 4: Test Admin-to-API Data Flow
Create new plan via Django Admin and verify it appears in API:

1. Open http://localhost:8000/admin/finances/pricingplan/
2. Add new plan:
   - Name: "Integration Test Plan"
   - Description: "Plan for testing admin-to-API integration"
   - Type: Package
   - Hours: 12.5
   - Price: €175.50
   - Validity: 40 days
   - Active: Yes
   - Featured: Yes

3. Save plan

4. Test API immediately after creation:
```bash
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
integration_plan = next((p for p in data if p['name'] == 'Integration Test Plan'), None)
if integration_plan:
    print('✓ New plan appears in API')
    print(f'  Name: {integration_plan[\"name\"]}')
    print(f'  Price: €{integration_plan[\"price_eur\"]}')
    print(f'  Featured: {integration_plan[\"is_featured\"]}')
else:
    print('✗ ERROR: New plan not found in API')
"
```

Expected: New plan immediately available via API
Screenshot: 02_admin_to_api_integration.png

Step 5: Test Cache Invalidation on Admin Changes
Test that cache updates when plans are modified:

First, populate cache:
```bash
curl -s http://localhost:8000/finances/api/pricing-plans/ > /tmp/before_edit.json
echo "Cache populated with initial request"
```

Edit plan via admin:
1. Edit "Integration Test Plan" in admin
2. Change price to €199.99
3. Save changes

Test API returns updated data:
```bash
curl -s http://localhost:8000/finances/api/pricing-plans/ > /tmp/after_edit.json

python -c "
import json
with open('/tmp/before_edit.json') as f:
    before = json.load(f)
with open('/tmp/after_edit.json') as f:
    after = json.load(f)

before_plan = next((p for p in before if p['name'] == 'Integration Test Plan'), None)
after_plan = next((p for p in after if p['name'] == 'Integration Test Plan'), None)

if before_plan and after_plan:
    before_price = before_plan['price_eur']
    after_price = after_plan['price_eur']
    print(f'Price before edit: €{before_price}')
    print(f'Price after edit: €{after_price}')
    if before_price != after_price and after_price == '199.99':
        print('✓ Cache properly invalidated, API shows updated data')
    else:
        print('✗ ERROR: Cache not invalidated or data not updated')
else:
    print('✗ ERROR: Could not find plan in API responses')
"
```

Expected: API immediately reflects admin changes (cache invalidated)

Step 6: Test Database Consistency Across Operations
Verify database state matches API and admin displays:

```bash
python manage.py shell -c "
from finances.models import PricingPlan
import json
import urllib.request

# Get data from database
db_plan = PricingPlan.objects.get(name='Integration Test Plan')
print(f'Database: {db_plan.name} - €{db_plan.price_eur}')

# Get data from API
with urllib.request.urlopen('http://localhost:8000/finances/api/pricing-plans/') as response:
    api_data = json.loads(response.read().decode())
    
api_plan = next((p for p in api_data if p['name'] == 'Integration Test Plan'), None)
if api_plan:
    print(f'API: {api_plan[\"name\"]} - €{api_plan[\"price_eur\"]}')
    
    # Compare critical fields
    db_price = str(db_plan.price_eur)
    api_price = api_plan['price_eur']
    
    if db_price == api_price:
        print('✓ Database and API data consistent')
    else:
        print(f'✗ ERROR: Database ({db_price}) != API ({api_price})')
else:
    print('✗ ERROR: Plan not found in API')
"
```

Expected: Database and API data perfectly consistent

Step 7: Test Bulk Operations Integration
Test bulk operations flow through all layers:

1. Via admin, select multiple plans
2. Use bulk action "Mark selected plans as featured"
3. Verify changes in API:

```bash
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
featured_plans = [p for p in data if p['is_featured']]
print(f'Featured plans count: {len(featured_plans)}')
for plan in featured_plans:
    print(f'  Featured: {plan[\"name\"]}')
"
```

Expected: Bulk changes immediately reflected in API

Step 8: Test Plan Activation/Deactivation Flow
Test active status filtering integration:

1. Deactivate a plan via admin (uncheck "is_active")
2. Verify it disappears from API:

```bash
# First, count current active plans
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
print(f'Active plans before deactivation: {len(data)}')
"

# Deactivate "Integration Test Plan" via admin interface
echo "Deactivate the Integration Test Plan via admin, then press Enter"
read

# Check API again
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
print(f'Active plans after deactivation: {len(data)}')
integration_plan = next((p for p in data if p['name'] == 'Integration Test Plan'), None)
if integration_plan:
    print('✗ ERROR: Deactivated plan still appears in API')
else:
    print('✓ Deactivated plan correctly filtered from API')
"
```

Expected: Deactivated plans immediately filtered from API

Step 9: Test Performance Under Load
Test system performance with realistic load:

```bash
echo "Testing API performance under load..."

# Test multiple concurrent requests
for i in {1..10}; do
  (curl -s http://localhost:8000/finances/api/pricing-plans/ \
    -w "Request $i: %{time_total}s\n" \
    -o /dev/null) &
done
wait

echo "Load testing complete"
```

Measure admin interface performance:
1. Navigate to pricing plans list
2. Perform various operations (search, filter, sort)
3. Note response times

Expected: Good performance under realistic load (all requests < 1 second)
Screenshot: 03_performance_testing.png

Step 10: Test Cross-Browser Compatibility (Admin Interface)
Test admin interface in different contexts:

1. Test admin in Chrome/Safari/Firefox
2. Test form submissions work consistently
3. Verify visual indicators appear correctly
4. Test responsive behavior

Expected: Consistent behavior across browsers
Screenshot: 04_cross_browser_testing.png

Step 11: Test Data Type and Format Consistency
Verify data types are consistent across all layers:

```bash
python manage.py shell -c "
from finances.models import PricingPlan
import json
import urllib.request
from decimal import Decimal

# Test plan from database
plan = PricingPlan.objects.first()
print(f'Database types:')
print(f'  hours_included: {type(plan.hours_included)} = {plan.hours_included}')
print(f'  price_eur: {type(plan.price_eur)} = {plan.price_eur}')
print(f'  validity_days: {type(plan.validity_days)} = {plan.validity_days}')

# Same plan from API
with urllib.request.urlopen('http://localhost:8000/finances/api/pricing-plans/') as response:
    api_data = json.loads(response.read().decode())
    api_plan = api_data[0]
    
print(f'API types:')
print(f'  hours_included: {type(api_plan[\"hours_included\"])} = {api_plan[\"hours_included\"]}')
print(f'  price_eur: {type(api_plan[\"price_eur\"])} = {api_plan[\"price_eur\"]}')
print(f'  validity_days: {type(api_plan[\"validity_days\"])} = {api_plan[\"validity_days\"]}')

# Verify serialization accuracy
db_hours = str(plan.hours_included)
api_hours = api_plan['hours_included']
if db_hours == api_hours:
    print('✓ Hours serialization accurate')
else:
    print(f'✗ Hours mismatch: DB={db_hours}, API={api_hours}')
"
```

Expected: Accurate data type conversion and serialization

Step 12: Test Frontend Data Format Compatibility
Verify API format is frontend-ready:

```bash
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)

print('Frontend compatibility check:')
for plan in data:
    # Check required fields for frontend
    required_fields = ['id', 'name', 'description', 'plan_type', 'hours_included', 'price_eur']
    missing = [field for field in required_fields if field not in plan]
    
    if missing:
        print(f'✗ {plan[\"name\"]} missing fields: {missing}')
    else:
        print(f'✓ {plan[\"name\"]} has all required fields')
    
    # Check data format suitability
    try:
        price = float(plan['price_eur'])
        hours = float(plan['hours_included'])
        print(f'  Price/Hours numeric conversion: ✓')
    except ValueError:
        print(f'  Price/Hours numeric conversion: ✗')
"
```

Expected: All plans have required fields in correct format

Step 13: Test Error Propagation and Handling
Test how errors propagate through the system:

1. Create invalid plan via admin (if possible)
2. Test API error responses
3. Verify database integrity maintained

```bash
# Test API with invalid request
curl -X POST http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -d '{"invalid": "data"}' \
  -w "\nStatus: %{http_code}\n"

# Verify database unaffected by invalid operations
python manage.py shell -c "
from finances.models import PricingPlan
print(f'Plan count after error test: {PricingPlan.objects.count()}')
print('Database integrity maintained')
"
```

Expected: Proper error handling without data corruption

Step 14: Test Cache Performance and Memory Usage
Monitor cache effectiveness:

```bash
python manage.py shell -c "
from django.core.cache import cache
import time

# Test cache hit/miss behavior
print('Testing cache effectiveness...')

# Clear cache and time first request
cache.delete('active_pricing_plans')
start = time.time()
# Simulate API request (cache miss)
import urllib.request
with urllib.request.urlopen('http://localhost:8000/finances/api/pricing-plans/') as response:
    data1 = response.read()
miss_time = time.time() - start

# Second request (cache hit)
start = time.time()
with urllib.request.urlopen('http://localhost:8000/finances/api/pricing-plans/') as response:
    data2 = response.read()
hit_time = time.time() - start

print(f'Cache miss time: {miss_time:.3f}s')
print(f'Cache hit time: {hit_time:.3f}s')
print(f'Performance improvement: {miss_time/hit_time:.1f}x')

if hit_time < miss_time * 0.5:
    print('✓ Cache providing significant performance benefit')
else:
    print('✗ Cache not providing expected performance benefit')
"
```

Expected: Cache provides measurable performance improvement

Step 15: Test Complete User Workflow End-to-End
Simulate complete business workflow:

1. Business user logs into admin
2. Creates new pricing plan via admin
3. Frontend user visits pricing page
4. API serves the new plan
5. User sees updated pricing options

Test this flow:
```bash
echo "Complete workflow test:"

# Step 1: Create plan via admin (manual)
echo "Create a plan named 'Workflow Test Plan' via admin interface, then press Enter"
read

# Step 2: Verify API serves new plan
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
workflow_plan = next((p for p in data if p['name'] == 'Workflow Test Plan'), None)
if workflow_plan:
    print('✓ Workflow plan available via API')
    print(f'  Plan: {workflow_plan[\"name\"]}')
    print(f'  Price: €{workflow_plan[\"price_eur\"]}')
    print(f'  Type: {workflow_plan[\"plan_type\"]}')
else:
    print('✗ ERROR: Workflow plan not found in API')
"

# Step 3: Verify plan would appear to frontend users
echo "Frontend users would see this plan in pricing options"
```

Expected: Complete workflow works seamlessly

Step 16: Test System Recovery and Cleanup
Test system handles cleanup and recovery:

```bash
# Clean up test data
python manage.py shell -c "
from finances.models import PricingPlan

# Remove test plans
test_plans = PricingPlan.objects.filter(
    name__in=['Integration Test Plan', 'Workflow Test Plan']
)
count = test_plans.count()
test_plans.delete()
print(f'Cleaned up {count} test plans')

# Clear cache
from django.core.cache import cache
cache.clear()
print('Cache cleared')
"

# Verify system still works after cleanup
curl -s http://localhost:8000/finances/api/pricing-plans/ | python -c "
import json, sys
data = json.load(sys.stdin)
print(f'Plans remaining after cleanup: {len(data)}')
print('System operational after cleanup')
"
```

Expected: System remains stable after cleanup

=== PASS/FAIL CRITERIA ===

PASS: All system components integrate correctly with data consistency and good performance
FAIL: Any integration failures, data inconsistencies, or performance issues

Individual Step Criteria:
- Step 1: PASS if clean state established, FAIL if setup issues
- Step 2: PASS if management command creates data correctly, FAIL if creation fails
- Step 3: PASS if API returns correct data, FAIL if data missing or wrong
- Step 4: PASS if admin changes appear in API, FAIL if admin-API integration broken
- Step 5: PASS if cache invalidates on changes, FAIL if stale data served
- Step 6: PASS if database and API consistent, FAIL if data mismatches
- Step 7: PASS if bulk operations flow through system, FAIL if operations don't propagate
- Step 8: PASS if activation status filtering works, FAIL if inactive plans appear
- Step 9: PASS if performance acceptable under load, FAIL if slow or failing requests
- Step 10: PASS if cross-browser compatibility good, FAIL if browser-specific issues
- Step 11: PASS if data types consistent, FAIL if serialization errors
- Step 12: PASS if frontend format compatible, FAIL if missing/wrong fields
- Step 13: PASS if error handling proper, FAIL if errors corrupt data
- Step 14: PASS if cache improves performance, FAIL if cache ineffective
- Step 15: PASS if complete workflow seamless, FAIL if any workflow step breaks
- Step 16: PASS if system stable after cleanup, FAIL if cleanup causes issues

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== INTEGRATION BENCHMARKS ===

Performance Standards:
- Admin-to-API propagation: Immediate (< 1 second)
- Cache hit performance: < 50ms
- Cache miss performance: < 500ms
- Bulk operations: Complete within 3 seconds
- Cross-component consistency: 100% data accuracy
- System stability: No errors or data corruption