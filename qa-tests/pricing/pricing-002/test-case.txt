QA Test Case: Pricing Plan Business Logic and Validation

Test ID: PRICING-002
Test Name: Business Logic Validation for Pricing Plan System
Purpose: Verify that all business logic rules, validation constraints, and calculations work correctly for the PricingPlan model
Expected Result: All business rules are enforced correctly with proper error messages and calculations

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Component: PricingPlan model business logic and validation
- Implementation: GitHub Issue #29 - Product Pricing Configuration Model
- Features: Model validation, price calculations, plan type constraints, manager filtering

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development

Test Focus Areas:
- Plan type validation (package vs subscription)
- Price and hours validation
- Price per hour calculations
- Model clean() method validation
- Manager custom querysets
- Database constraints

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Django Shell Access
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  cd backend
  python manage.py shell

Expected: Django shell starts successfully
Import required models:
```python
from finances.models import PricingPlan, PlanType
from decimal import Decimal
from django.core.exceptions import ValidationError
```

Step 2: Test Package Plan Validation Rules
Create valid package plan:
```python
# Test valid package plan
valid_package = PricingPlan(
    name="Test Valid Package",
    description="Valid package for testing",
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('10.00'),
    price_eur=Decimal('150.00'),
    validity_days=30,
    display_order=1
)
valid_package.full_clean()  # Should not raise exception
valid_package.save()
print(f"Valid package created: {valid_package}")
```

Expected: Valid package saves without errors
Test validation successful if no ValidationError raised

Step 3: Test Package Plan Validation Failures
Test package without validity_days:
```python
# Test invalid package - missing validity_days
try:
    invalid_package = PricingPlan(
        name="Invalid Package No Validity",
        description="Package without validity days",
        plan_type=PlanType.PACKAGE,
        hours_included=Decimal('5.00'),
        price_eur=Decimal('75.00'),
        validity_days=None,  # Invalid for packages
        display_order=2
    )
    invalid_package.full_clean()
    print("ERROR: Should have failed validation!")
except ValidationError as e:
    print(f"Correct validation error: {e}")
    assert "Package plans must have validity_days specified" in str(e)
```

Expected: ValidationError raised with correct message

Step 4: Test Subscription Plan Validation Rules
Create valid subscription plan:
```python
# Test valid subscription plan
valid_subscription = PricingPlan(
    name="Test Valid Subscription",
    description="Valid subscription for testing",
    plan_type=PlanType.SUBSCRIPTION,
    hours_included=Decimal('20.00'),
    price_eur=Decimal('199.00'),
    validity_days=None,  # Correct for subscriptions
    display_order=3
)
valid_subscription.full_clean()  # Should not raise exception
valid_subscription.save()
print(f"Valid subscription created: {valid_subscription}")
```

Expected: Valid subscription saves without errors

Step 5: Test Subscription Plan Validation Failures
Test subscription with validity_days:
```python
# Test invalid subscription - has validity_days
try:
    invalid_subscription = PricingPlan(
        name="Invalid Subscription With Validity",
        description="Subscription with validity days",
        plan_type=PlanType.SUBSCRIPTION,
        hours_included=Decimal('15.00'),
        price_eur=Decimal('149.00'),
        validity_days=30,  # Invalid for subscriptions
        display_order=4
    )
    invalid_subscription.full_clean()
    print("ERROR: Should have failed validation!")
except ValidationError as e:
    print(f"Correct validation error: {e}")
    assert "Subscription plans should not have validity_days" in str(e)
```

Expected: ValidationError raised with correct message

Step 6: Test Price and Hours Validation
Test negative and zero values:
```python
# Test zero price
try:
    zero_price_plan = PricingPlan(
        name="Zero Price Plan",
        description="Plan with zero price",
        plan_type=PlanType.PACKAGE,
        hours_included=Decimal('10.00'),
        price_eur=Decimal('0.00'),  # Invalid
        validity_days=30,
        display_order=5
    )
    zero_price_plan.full_clean()
    print("ERROR: Should have failed validation!")
except ValidationError as e:
    print(f"Correct validation error for zero price: {e}")

# Test zero hours
try:
    zero_hours_plan = PricingPlan(
        name="Zero Hours Plan",
        description="Plan with zero hours",
        plan_type=PlanType.PACKAGE,
        hours_included=Decimal('0.00'),  # Invalid
        price_eur=Decimal('100.00'),
        validity_days=30,
        display_order=6
    )
    zero_hours_plan.full_clean()
    print("ERROR: Should have failed validation!")
except ValidationError as e:
    print(f"Correct validation error for zero hours: {e}")

# Test negative validity days
try:
    negative_validity_plan = PricingPlan(
        name="Negative Validity Plan",
        description="Plan with negative validity",
        plan_type=PlanType.PACKAGE,
        hours_included=Decimal('10.00'),
        price_eur=Decimal('100.00'),
        validity_days=-5,  # Invalid
        display_order=7
    )
    negative_validity_plan.full_clean()
    print("ERROR: Should have failed validation!")
except ValidationError as e:
    print(f"Correct validation error for negative validity: {e}")
```

Expected: All invalid values raise appropriate ValidationErrors

Step 7: Test Price Per Hour Calculation
Test calculation accuracy:
```python
# Test price per hour calculation
test_plan = PricingPlan(
    name="Price Calculation Test",
    description="Test price per hour calculation",
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('8.00'),
    price_eur=Decimal('120.00'),
    validity_days=30,
    display_order=8
)
test_plan.save()

calculated_price_per_hour = test_plan.price_per_hour
expected_price_per_hour = Decimal('120.00') / Decimal('8.00')

print(f"Calculated price per hour: {calculated_price_per_hour}")
print(f"Expected price per hour: {expected_price_per_hour}")
assert calculated_price_per_hour == expected_price_per_hour

# Test with zero hours (edge case)
zero_hours_test = PricingPlan.objects.create(
    name="Zero Hours Edge Case",
    description="Edge case with zero hours",
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('0.01'),  # Minimum valid value
    price_eur=Decimal('1.00'),
    validity_days=1,
    display_order=9
)

edge_case_price = zero_hours_test.price_per_hour
print(f"Edge case price per hour: {edge_case_price}")
assert edge_case_price is not None
```

Expected: Price per hour calculations are accurate and handle edge cases

Step 8: Test Model Managers and Querysets
Test custom managers:
```python
# Test default manager ordering
all_plans = PricingPlan.objects.all()
print("All plans (default manager):")
for plan in all_plans:
    print(f"  {plan.display_order}: {plan.name}")

# Verify ordering by display_order, then name
previous_order = 0
for plan in all_plans:
    assert plan.display_order >= previous_order
    previous_order = plan.display_order

# Test active manager
active_plans = PricingPlan.active.all()
print(f"\nActive plans count: {active_plans.count()}")
for plan in active_plans:
    assert plan.is_active == True
    print(f"  Active: {plan.name}")

# Create inactive plan to test filtering
inactive_plan = PricingPlan.objects.create(
    name="Inactive Test Plan",
    description="Plan for testing inactive filtering",
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('5.00'),
    price_eur=Decimal('50.00'),
    validity_days=15,
    display_order=999,
    is_active=False
)

# Verify inactive plan not in active manager results
active_after_inactive = PricingPlan.active.all()
assert inactive_plan not in active_after_inactive
print(f"Inactive plan correctly filtered out")
```

Expected: Managers filter and order correctly

Step 9: Test String Representation and Display Methods
Test __str__ method and display formatting:
```python
# Test string representation
package_str = valid_package.__str__()
subscription_str = valid_subscription.__str__()

print(f"Package string representation: {package_str}")
print(f"Subscription string representation: {subscription_str}")

# Verify format includes key information
assert valid_package.name in package_str
assert str(valid_package.price_eur) in package_str
assert str(valid_package.hours_included) in package_str
assert "days" in package_str  # Package should show validity

assert valid_subscription.name in subscription_str
assert str(valid_subscription.price_eur) in subscription_str
assert str(valid_subscription.hours_included) in subscription_str
assert "subscription" in subscription_str  # Subscription should show type
```

Expected: String representations are informative and correctly formatted

Step 10: Test Database Constraints and Indexes
Test that database constraints work:
```python
# Test unique constraints if any exist
# Test that indexes are being used for queries
from django.db import connection

# Test a query that should use indexes
with connection.cursor() as cursor:
    # Query active plans ordered by display_order
    active_plans_query = PricingPlan.active.filter(is_featured=True)
    list(active_plans_query)  # Execute query
    
    # Check that the query executed successfully
    print("Index-based query executed successfully")

# Test plan type filtering (should use index)
package_plans = PricingPlan.objects.filter(plan_type=PlanType.PACKAGE)
subscription_plans = PricingPlan.objects.filter(plan_type=PlanType.SUBSCRIPTION)

print(f"Package plans found: {package_plans.count()}")
print(f"Subscription plans found: {subscription_plans.count()}")
```

Expected: Database queries execute efficiently using indexes

Step 11: Test Edge Cases and Boundary Values
Test boundary conditions:
```python
# Test minimum valid values
min_valid_plan = PricingPlan(
    name="Minimum Valid Plan",
    description="Plan with minimum valid values",
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('0.01'),  # Minimum from validator
    price_eur=Decimal('0.01'),       # Minimum from validator
    validity_days=1,                 # Minimum from validator
    display_order=1
)
min_valid_plan.full_clean()
min_valid_plan.save()
print(f"Minimum valid plan created: {min_valid_plan}")

# Test large values
large_values_plan = PricingPlan(
    name="Large Values Plan",
    description="Plan with large values",
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('999.99'),  # Large but valid
    price_eur=Decimal('9999.99'),      # Large but valid
    validity_days=365,                 # Large but reasonable
    display_order=999
)
large_values_plan.full_clean()
large_values_plan.save()
print(f"Large values plan created: {large_values_plan}")
```

Expected: Boundary values are handled correctly

Step 12: Test Model Metadata and Configuration
Verify model configuration:
```python
# Test model metadata
assert PricingPlan._meta.verbose_name == "Pricing Plan"
assert PricingPlan._meta.verbose_name_plural == "Pricing Plans"
assert PricingPlan._meta.ordering == ["display_order", "name"]

# Test field configurations
name_field = PricingPlan._meta.get_field('name')
assert name_field.max_length == 100

price_field = PricingPlan._meta.get_field('price_eur')
assert price_field.max_digits == 6
assert price_field.decimal_places == 2

hours_field = PricingPlan._meta.get_field('hours_included')
assert hours_field.max_digits == 5
assert hours_field.decimal_places == 2

print("Model metadata verification complete")
```

Expected: All model metadata is correctly configured

Step 13: Cleanup Test Data
Remove test plans created during testing:
```python
# Clean up test data
test_plan_names = [
    "Test Valid Package",
    "Test Valid Subscription", 
    "Price Calculation Test",
    "Zero Hours Edge Case",
    "Inactive Test Plan",
    "Minimum Valid Plan",
    "Large Values Plan"
]

for name in test_plan_names:
    try:
        plan = PricingPlan.objects.get(name=name)
        plan.delete()
        print(f"Deleted test plan: {name}")
    except PricingPlan.DoesNotExist:
        print(f"Test plan not found: {name}")

print("Cleanup complete")
```

Expected: All test data cleaned up successfully

=== PASS/FAIL CRITERIA ===

PASS: All business logic rules work correctly with proper validation and calculations
FAIL: Any validation rule fails to work or calculations are incorrect

Individual Step Criteria:
- Step 1: PASS if Django shell loads, FAIL if environment setup fails
- Step 2: PASS if valid package creates without errors, FAIL if valid plan rejected
- Step 3: PASS if invalid package raises correct ValidationError, FAIL if saves or wrong error
- Step 4: PASS if valid subscription creates without errors, FAIL if valid plan rejected
- Step 5: PASS if invalid subscription raises correct ValidationError, FAIL if saves or wrong error
- Step 6: PASS if all invalid values raise ValidationErrors, FAIL if any invalid value saves
- Step 7: PASS if price calculations are accurate, FAIL if calculations wrong
- Step 8: PASS if managers filter and order correctly, FAIL if queries return wrong results
- Step 9: PASS if string representations are informative, FAIL if missing key information
- Step 10: PASS if database queries execute properly, FAIL if constraint violations
- Step 11: PASS if boundary values handled correctly, FAIL if edge cases fail
- Step 12: PASS if model metadata is correct, FAIL if configuration errors
- Step 13: PASS if cleanup completes, FAIL if test data remains

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== VALIDATION CHECKPOINTS ===

Critical Validation Points:
1. Package plans MUST have validity_days
2. Subscription plans MUST NOT have validity_days  
3. Prices and hours MUST be positive
4. Price per hour calculation MUST be accurate
5. Active manager MUST filter correctly
6. Model ordering MUST work as specified