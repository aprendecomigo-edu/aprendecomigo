QA Test Case: Public API Endpoint for Pricing Plans

Test ID: PRICING-003
Test Name: Public API Endpoint Testing with Caching Validation
Purpose: Verify that the public API endpoint /finances/api/pricing-plans/ works correctly with proper caching, response format, and performance
Expected Result: API returns active pricing plans with 1-hour caching, proper JSON format, and unauthenticated access

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Component: Public API endpoint for pricing plans
- Implementation: GitHub Issue #29 - Product Pricing Configuration Model
- Endpoint: GET /finances/api/pricing-plans/
- Features: Public access, 1-hour caching, active plans only, ordered results

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
4. Tools: curl, browser, or HTTP client for API testing

Test Focus Areas:
- Unauthenticated API access
- Caching behavior (1-hour cache)
- Response format and structure
- Active plans filtering
- Ordering by display_order
- Performance and response times

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Service Start
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected: Both services start successfully
- Backend: http://localhost:8000 API available
- Cache system: Redis or database cache working

Step 2: Verify Service Availability
Test basic API accessibility:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -w "\nStatus: %{http_code}\nTime: %{time_total}s\n"
```

Expected: 
- HTTP 200 OK response
- Response time under 1 second
- JSON content returned

Screenshot: 01_api_basic_response.png

Step 3: Test Unauthenticated Access
Verify the endpoint allows public access:
```bash
# Test without any authentication headers
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -i
```

Expected:
- HTTP 200 OK (not 401 Unauthorized)
- No authentication required
- Full response data returned

Step 4: Analyze Response Structure and Content
Test response format and data structure:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -s | python -m json.tool
```

Expected JSON structure for each plan:
```json
[
  {
    "id": 1,
    "name": "Plan Name",
    "description": "Plan description",
    "plan_type": "package" | "subscription",
    "hours_included": "10.00",
    "price_eur": "150.00",
    "validity_days": 30 | null,
    "display_order": 1,
    "is_featured": true | false,
    "is_active": true,
    "created_at": "2024-XX-XXTXX:XX:XX.XXXXXXZ",
    "updated_at": "2024-XX-XXTXX:XX:XX.XXXXXXZ"
  }
]
```

Verify:
- All plans returned have is_active: true
- Plans are ordered by display_order
- All required fields are present
- Decimal fields are properly formatted

Screenshot: 02_response_structure_validation.png

Step 5: Test Active Plans Filtering
Create inactive plan and verify it's not returned:

First, create an inactive plan via Django admin or shell:
```bash
python manage.py shell -c "
from finances.models import PricingPlan, PlanType
from decimal import Decimal
inactive_plan = PricingPlan.objects.create(
    name='Inactive Test Plan for API',
    description='Should not appear in API response',
    plan_type=PlanType.PACKAGE,
    hours_included=Decimal('5.00'),
    price_eur=Decimal('50.00'),
    validity_days=30,
    display_order=999,
    is_active=False
)
print(f'Created inactive plan: {inactive_plan.id}')
"
```

Then test API response:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -s | python -c "
import json, sys
data = json.load(sys.stdin)
inactive_plans = [p for p in data if not p['is_active']]
print(f'Inactive plans in response: {len(inactive_plans)}')
if inactive_plans:
    print('ERROR: Inactive plans found in response!')
    for plan in inactive_plans:
        print(f'  - {plan[\"name\"]} (active: {plan[\"is_active\"]})')
else:
    print('SUCCESS: No inactive plans in response')
"
```

Expected: No inactive plans in API response

Step 6: Test Caching Behavior - First Request
Test initial cache population:
```bash
# Clear cache first (if using Redis)
# redis-cli FLUSHDB (if Redis available)

# Or via Django shell
python manage.py shell -c "
from django.core.cache import cache
cache.clear()
print('Cache cleared')
"

# Make first request and measure time
echo "First request (cache miss):"
time curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -w "\nTime: %{time_total}s\n" \
  -o /tmp/first_response.json

# Save timestamp of first request
date +%s > /tmp/first_request_time
```

Expected: 
- Response time reflects database query
- Cache is populated after this request

Step 7: Test Caching Behavior - Cached Request
Test cache hit performance:
```bash
echo "Second request (cache hit):"
time curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -w "\nTime: %{time_total}s\n" \
  -o /tmp/second_response.json

# Compare response content
echo "Comparing responses:"
diff /tmp/first_response.json /tmp/second_response.json
echo "Responses should be identical"
```

Expected:
- Faster response time (cache hit)
- Identical response content
- No database query for cached request

Step 8: Test Cache Expiration (Optional - Time Intensive)
Note: This step would require waiting 1 hour or manually expiring cache

For testing purposes, manually expire cache:
```bash
python manage.py shell -c "
from django.core.cache import cache
cache.delete('active_pricing_plans')
print('Cache manually expired')
"

echo "Request after cache expiration:"
time curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -w "\nTime: %{time_total}s\n" \
  -o /tmp/expired_response.json
```

Expected: Response time increases (cache miss, database query)

Step 9: Test Response Ordering
Verify plans are returned in correct order:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -s | python -c "
import json, sys
data = json.load(sys.stdin)
print('Plans ordering verification:')
previous_order = 0
for i, plan in enumerate(data):
    current_order = plan['display_order']
    print(f'{i+1}. {plan[\"name\"]} (order: {current_order})')
    if current_order < previous_order:
        print('ERROR: Plans not properly ordered by display_order!')
        sys.exit(1)
    previous_order = current_order
print('SUCCESS: Plans correctly ordered by display_order')
"
```

Expected: Plans ordered by display_order, then by name

Step 10: Test Featured Plans Identification
Verify featured status is properly included:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -s | python -c "
import json, sys
data = json.load(sys.stdin)
featured_plans = [p for p in data if p['is_featured']]
regular_plans = [p for p in data if not p['is_featured']]
print(f'Featured plans: {len(featured_plans)}')
print(f'Regular plans: {len(regular_plans)}')
for plan in featured_plans:
    print(f'  Featured: {plan[\"name\"]}')
"
```

Expected: Featured status correctly identified for promotional plans

Step 11: Test Response Headers and Content Type
Verify proper HTTP headers:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -I \
  -H "Content-Type: application/json"
```

Expected headers:
- Content-Type: application/json
- HTTP/1.1 200 OK
- Proper cache headers if configured

Screenshot: 03_response_headers.png

Step 12: Test Error Handling and Edge Cases
Test various edge cases:

Test with invalid HTTP method:
```bash
echo "Testing POST method (should be 405):"
curl -X POST http://localhost:8000/finances/api/pricing-plans/ \
  -H "Content-Type: application/json" \
  -w "\nStatus: %{http_code}\n"
```

Test with query parameters (should be ignored):
```bash
echo "Testing with query parameters:"
curl -X GET "http://localhost:8000/finances/api/pricing-plans/?invalid=param" \
  -H "Content-Type: application/json" \
  -w "\nStatus: %{http_code}\n"
```

Expected:
- POST returns 405 Method Not Allowed
- Query parameters ignored, normal response returned

Step 13: Performance and Load Testing
Test multiple concurrent requests:
```bash
echo "Performance testing with multiple requests:"
for i in {1..5}; do
  (curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
    -w "\nRequest $i time: %{time_total}s\n" \
    -o /dev/null -s) &
done
wait
echo "All concurrent requests completed"
```

Expected: All requests complete successfully within reasonable time

Step 14: Cross-Origin Request Testing (If CORS enabled)
Test CORS headers if applicable:
```bash
curl -X OPTIONS http://localhost:8000/finances/api/pricing-plans/ \
  -H "Origin: http://localhost:3000" \
  -H "Access-Control-Request-Method: GET" \
  -H "Access-Control-Request-Headers: Content-Type" \
  -i
```

Expected: Appropriate CORS headers if CORS is configured

Step 15: Integration with Frontend Format
Verify response format matches frontend expectations:
```bash
curl -X GET http://localhost:8000/finances/api/pricing-plans/ \
  -s | python -c "
import json, sys
data = json.load(sys.stdin)
print('Frontend integration verification:')
for plan in data:
    required_fields = ['id', 'name', 'description', 'plan_type', 'hours_included', 'price_eur', 'is_featured']
    missing_fields = [field for field in required_fields if field not in plan]
    if missing_fields:
        print(f'ERROR: Missing fields in {plan[\"name\"]}: {missing_fields}')
    else:
        print(f'âœ“ {plan[\"name\"]} has all required fields')
"
```

Expected: All plans have required fields for frontend consumption

Step 16: Cleanup Test Data
Remove test data created during testing:
```bash
python manage.py shell -c "
from finances.models import PricingPlan
try:
    test_plan = PricingPlan.objects.get(name='Inactive Test Plan for API')
    test_plan.delete()
    print('Removed test inactive plan')
except PricingPlan.DoesNotExist:
    print('Test plan already removed')
"
```

Expected: Test data cleaned up successfully

=== PASS/FAIL CRITERIA ===

PASS: API endpoint works correctly with proper caching, response format, and performance
FAIL: Any API functionality fails, caching doesn't work, or response format is incorrect

Individual Step Criteria:
- Step 1: PASS if services start, FAIL if API unavailable
- Step 2: PASS if basic API response works, FAIL if errors or slow response
- Step 3: PASS if unauthenticated access works, FAIL if authentication required
- Step 4: PASS if response structure is correct, FAIL if missing fields or wrong format
- Step 5: PASS if only active plans returned, FAIL if inactive plans included
- Step 6: PASS if cache populated correctly, FAIL if caching not working
- Step 7: PASS if cache hit improves performance, FAIL if no performance improvement
- Step 8: PASS if cache expiration works, FAIL if stale data served
- Step 9: PASS if ordering is correct, FAIL if plans not properly ordered
- Step 10: PASS if featured status correct, FAIL if featured flag missing or wrong
- Step 11: PASS if headers are proper, FAIL if wrong content type or status
- Step 12: PASS if error handling works, FAIL if improper error responses
- Step 13: PASS if performance acceptable, FAIL if requests timeout or fail
- Step 14: PASS if CORS works (if enabled), FAIL if CORS blocks requests
- Step 15: PASS if frontend format correct, FAIL if missing required fields
- Step 16: PASS if cleanup successful, FAIL if test data remains

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== PERFORMANCE BENCHMARKS ===

Expected Performance:
- First request (cache miss): < 500ms
- Cached request: < 50ms
- Concurrent requests: All complete within 2 seconds
- Cache duration: 1 hour (3600 seconds)