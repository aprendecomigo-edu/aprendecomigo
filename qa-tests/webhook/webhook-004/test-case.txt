================================================================================
STRIPE WEBHOOK ERROR HANDLING VALIDATION
================================================================================

Test ID: WEBHOOK-004
Test Name: Stripe Webhook Error Handling and Graceful Degradation
Test Type: Reliability/Error Handling
Priority: Critical
Estimated Time: 40 minutes

================================================================================
TEST PURPOSE
================================================================================

Validate that the Stripe webhook handler gracefully handles all error scenarios:
‚úÖ Malformed JSON payloads and invalid request data
‚úÖ Database connection failures and transaction rollbacks
‚úÖ PaymentService API failures and recovery
‚úÖ Non-existent payment intent references
‚úÖ Corrupted webhook event data
‚úÖ Server resource exhaustion scenarios
‚úÖ Graceful degradation without data corruption
‚úÖ Proper HTTP status codes for Stripe retry logic

This test ensures the webhook remains stable and secure under all error conditions
while providing proper feedback to Stripe's retry mechanism.

================================================================================
PREREQUISITES
================================================================================

‚úÖ Virtual environment configured (.venv directory exists)
‚úÖ Dependencies installed (backend/requirements.txt)
‚úÖ Test database with clean state
‚úÖ Stripe CLI installed for error simulation
‚úÖ STRIPE_WEBHOOK_SECRET configured

================================================================================
TEST PROCEDURE
================================================================================

Step 1: Environment Setup and Service Start
===========================================
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected:
‚úÖ Django development server starts on port 8000
‚úÖ Backend accessible at http://localhost:8000/api/
‚úÖ Webhook endpoint available at /api/finances/webhooks/stripe/

Screenshot: 01-servers-started.png
Duration: ~15 seconds

Step 2: Test Malformed JSON Payload Handling
=============================================
Commands:
  # Test invalid JSON structure
  curl -X POST http://localhost:8000/api/finances/webhooks/stripe/ \
    -H "Content-Type: application/json" \
    -H "Stripe-Signature: t=1234567890,v1=dummy_signature" \
    -d '{invalid_json_structure'

Expected:
‚úÖ HTTP 400 Bad Request response
‚úÖ Server handles malformed JSON without crashing
‚úÖ Appropriate error message in response
‚úÖ No database changes or side effects
‚úÖ Error logged with request details

Screenshot: 02-malformed-json-handled.png

Step 3: Test Empty Payload Handling
====================================
Commands:
  # Test completely empty payload
  curl -X POST http://localhost:8000/api/finances/webhooks/stripe/ \
    -H "Content-Type: application/json" \
    -H "Stripe-Signature: t=1234567890,v1=dummy_signature" \
    -d ''

Expected:
‚úÖ HTTP 400 Bad Request response
‚úÖ Empty payload handled gracefully
‚úÖ No server errors or exceptions
‚úÖ Proper error logging

Screenshot: 03-empty-payload-handled.png

Step 4: Test Oversized Payload Handling
========================================
Commands:
  # Create very large payload to test limits
  python -c "
import requests
import json

# Create 1MB payload
large_data = {'x' * 1000: 'y' * 1000 for _ in range(1000)}
payload = {'type': 'test.large', 'data': large_data}

try:
    response = requests.post(
        'http://localhost:8000/api/finances/webhooks/stripe/',
        json=payload,
        headers={
            'Content-Type': 'application/json',
            'Stripe-Signature': 't=1234567890,v1=dummy_signature'
        },
        timeout=30
    )
    print(f'Status: {response.status_code}')
    print(f'Response length: {len(response.text)}')
except Exception as e:
    print(f'Error: {e}')
"

Expected:
‚úÖ Large payload handled without server crash
‚úÖ Appropriate response (likely 400 for missing signature)
‚úÖ No memory exhaustion or performance degradation
‚úÖ Server remains responsive

Screenshot: 04-oversized-payload-handled.png

Step 5: Test Non-Existent Payment Intent Handling
==================================================
Commands:
  # Create webhook payload referencing non-existent payment intent
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_nonexistent_999

Expected:
‚úÖ Webhook receives event with valid signature
‚úÖ PaymentService handles non-existent payment intent gracefully
‚úÖ HTTP 500 response (indicating processing failure for Stripe retry)
‚úÖ Error logged with payment intent ID
‚úÖ No database corruption or undefined state

Screenshot: 05-nonexistent-payment-intent.png

Step 6: Test Database Connection Failure Simulation
====================================================
Commands:
  # Temporarily break database connection to test error handling
  python manage.py shell -c "
from django.db import connection
from django.test.utils import override_settings

# Test webhook behavior when database is unavailable
print('Testing database connection failure scenarios...')
print('This would typically require database service interruption')
print('For safety, we will simulate this with connection limits')
"

  # Send webhook event during potential database stress
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_test_db_error

Expected:
‚úÖ Database connection issues handled gracefully
‚úÖ HTTP 500 response to trigger Stripe retry
‚úÖ Atomic transaction rollback prevents partial data
‚úÖ Error logging captures database failure details
‚úÖ No data corruption from failed operations

Screenshot: 06-database-failure-handling.png

Step 7: Test PaymentService API Failure Handling
=================================================
Commands:
  # Create test transaction for API failure testing
  cd backend
  python manage.py test_stripe_webhook --create-test-data --payment-intent-id pi_test_api_failure

  # Simulate PaymentService failure by temporarily modifying code behavior
  # For testing purposes, we'll check the logs for error handling
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_test_api_failure

Expected:
‚úÖ PaymentService errors handled gracefully
‚úÖ HTTP 500 response for processing failures
‚úÖ Exception logging with full stack trace
‚úÖ Transaction remains in safe state (no partial updates)
‚úÖ Error details logged for debugging

Screenshot: 07-payment-service-failure.png

Step 8: Test Corrupted Event Data Handling
===========================================
Commands:
  # Test webhook with corrupted event structure
  python -c "
import requests
import json
import time
import hmac
import hashlib

# Create corrupted event data
corrupted_event = {
    'type': 'payment_intent.succeeded',
    'data': {
        'object': {
            'id': None,  # Null ID should cause issues
            'status': 'corrupted_data',
            'amount': 'not_a_number',  # Invalid amount type
            'metadata': 'should_be_dict'  # Wrong metadata type
        }
    }
}

payload = json.dumps(corrupted_event)
print('Sending corrupted event data...')
print(f'Payload: {payload[:200]}...')

try:
    response = requests.post(
        'http://localhost:8000/api/finances/webhooks/stripe/',
        data=payload,
        headers={
            'Content-Type': 'application/json',
            'Stripe-Signature': 't=1234567890,v1=dummy_signature'
        }
    )
    print(f'Status: {response.status_code}')
    print(f'Response: {response.text[:200]}')
except Exception as e:
    print(f'Request error: {e}')
"

Expected:
‚úÖ Corrupted event data handled without server crash
‚úÖ Data validation errors caught and logged
‚úÖ HTTP 400 or 500 response depending on error type
‚úÖ No database writes with invalid data
‚úÖ Structured error logging for debugging

Screenshot: 08-corrupted-event-data.png

Step 9: Test Concurrent Error Scenarios
========================================
Commands:
  # Send multiple problematic requests concurrently
  for i in {1..5}; do
    curl -X POST http://localhost:8000/api/finances/webhooks/stripe/ \
      -H "Content-Type: application/json" \
      -H "Stripe-Signature: invalid_sig_$i" \
      -d "{\"type\": \"error_test_$i\", \"id\": \"evt_$i\"}" &
  done
  wait

Expected:
‚úÖ Multiple concurrent error requests handled safely
‚úÖ No server instability or resource exhaustion
‚úÖ Each request receives appropriate error response
‚úÖ Error handling remains consistent under load
‚úÖ Server continues accepting valid requests

Screenshot: 09-concurrent-error-handling.png

Step 10: Test Memory and Resource Exhaustion Protection
========================================================
Commands:
  # Test webhook behavior under resource pressure
  python -c "
import requests
import threading
import time

def send_error_request(thread_id):
    try:
        # Send request with large headers
        large_signature = 'v1=' + 'x' * 10000
        response = requests.post(
            'http://localhost:8000/api/finances/webhooks/stripe/',
            json={'type': 'resource_test', 'id': f'evt_{thread_id}'},
            headers={
                'Content-Type': 'application/json',
                'Stripe-Signature': f't=1234567890,{large_signature}'
            },
            timeout=10
        )
        print(f'Thread {thread_id}: {response.status_code}')
    except Exception as e:
        print(f'Thread {thread_id} error: {e}')

# Start multiple threads to test resource limits
threads = []
for i in range(10):
    thread = threading.Thread(target=send_error_request, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
"

Expected:
‚úÖ Resource limits protected against exhaustion
‚úÖ Large headers handled without memory issues
‚úÖ Thread limits prevent server overload
‚úÖ All requests receive responses (even if error)
‚úÖ Server remains stable under resource pressure

Screenshot: 10-resource-exhaustion-protection.png

Step 11: Test Error Recovery and Logging
=========================================
Commands:
  # Check comprehensive error logging
  make logs | grep -i "error\|exception\|webhook" | tail -20

Expected:
‚úÖ All error scenarios properly logged
‚úÖ Error messages include sufficient debugging information
‚úÖ No sensitive information leaked in error logs
‚úÖ Stack traces available for server errors
‚úÖ Structured logging format for monitoring

Screenshot: 11-error-logging-comprehensive.png

Step 12: Test Webhook Availability During Errors
=================================================
Commands:
  # Verify webhook remains available after error scenarios
  python manage.py test_stripe_webhook --test-endpoint

Expected:
‚úÖ Webhook endpoint still responding correctly
‚úÖ Basic security tests still pass
‚úÖ Error handling didn't break normal functionality
‚úÖ Server recovered from all error scenarios
‚úÖ No persistent error states

Screenshot: 12-webhook-availability-verified.png

Step 13: Test Error Response Format Consistency
================================================
Commands:
  # Test various error scenarios for consistent response format
  echo "Testing signature error..."
  curl -s -X POST http://localhost:8000/api/finances/webhooks/stripe/ \
    -H "Content-Type: application/json" \
    -H "Stripe-Signature: invalid" \
    -d '{}' | head -c 100

  echo -e "\nTesting JSON error..."
  curl -s -X POST http://localhost:8000/api/finances/webhooks/stripe/ \
    -H "Content-Type: application/json" \
    -H "Stripe-Signature: t=123,v1=abc" \
    -d 'invalid json' | head -c 100

  echo -e "\nTesting method error..."
  curl -s -X GET http://localhost:8000/api/finances/webhooks/stripe/ | head -c 100

Expected:
‚úÖ Consistent error response format across error types
‚úÖ Appropriate HTTP status codes for each error category
‚úÖ Error messages clear but not revealing internal details
‚úÖ Response format suitable for Stripe retry logic
‚úÖ No HTML error pages (JSON responses only)

Screenshot: 13-error-response-consistency.png

Step 14: Verify No Data Corruption After Errors
=================================================
Commands:
  # Check database integrity after all error scenarios
  python manage.py shell -c "
from finances.models import PurchaseTransaction, StudentAccountBalance
from accounts.models import CustomUser

# Check for any corrupted or partial data
print('=== DATA INTEGRITY CHECK ===')
try:
    transactions = PurchaseTransaction.objects.all()
    print(f'Total transactions: {transactions.count()}')
    
    for t in transactions:
        print(f'Transaction {t.id}: {t.payment_status} - Valid: {t.stripe_payment_intent_id is not None}')
    
    balances = StudentAccountBalance.objects.all()
    print(f'Total balances: {balances.count()}')
    
    for b in balances:
        print(f'Balance {b.id}: Hours={b.hours_purchased}, Amount={b.balance_amount}')
        
    print('Database integrity: VERIFIED')
except Exception as e:
    print(f'Database integrity issue: {e}')
"

Expected:
‚úÖ No corrupted transaction records
‚úÖ No invalid or partial database entries
‚úÖ All existing data remains consistent
‚úÖ Error scenarios didn't cause data pollution
‚úÖ Database constraints maintained

Screenshot: 14-data-integrity-verified.png

Step 15: Test Graceful Shutdown Under Error Load
=================================================
Commands:
  # Test server shutdown behavior during error processing
  # Start error load in background
  python -c "
import requests
import threading
import time

def continuous_error_requests():
    for i in range(20):
        try:
            requests.post(
                'http://localhost:8000/api/finances/webhooks/stripe/',
                json={'error_test': i},
                timeout=5
            )
        except:
            pass
        time.sleep(0.1)

thread = threading.Thread(target=continuous_error_requests)
thread.start()
print('Started continuous error requests...')
time.sleep(2)
" &

  # Test graceful shutdown
  sleep 5
  make stop

Expected:
‚úÖ Server shuts down gracefully despite ongoing error requests
‚úÖ No hanging processes or resource leaks
‚úÖ Error requests handled until shutdown
‚úÖ Clean termination without forced kills
‚úÖ All resources properly cleaned up

Screenshot: 15-graceful-shutdown-verified.png

================================================================================
CLEANUP
================================================================================

Commands:
  # Ensure clean shutdown
  make stop
  # Clean up any test data
  cd backend && python manage.py flush --noinput

Expected:
‚úÖ All processes terminated
‚úÖ Test database cleaned
‚úÖ System ready for next test

================================================================================
PASS/FAIL CRITERIA
================================================================================

‚úÖ PASS: All error scenarios handled gracefully without server crashes
‚úÖ PASS: Appropriate HTTP status codes returned for Stripe retry logic
‚úÖ PASS: Database integrity maintained during all error conditions
‚úÖ PASS: No memory leaks or resource exhaustion under error load
‚úÖ PASS: Comprehensive error logging for debugging and monitoring
‚úÖ PASS: Consistent error response format across all scenarios
‚úÖ PASS: Server remains available and functional after error scenarios

‚ùå FAIL: Any server crashes or unhandled exceptions
‚ùå FAIL: Database corruption or inconsistent state after errors
‚ùå FAIL: Memory leaks or resource exhaustion issues
‚ùå FAIL: Inadequate error logging or debugging information
‚ùå FAIL: Inconsistent error responses or inappropriate status codes
‚ùå FAIL: Server instability or performance degradation after errors

================================================================================
CRITICAL IMPORTANCE
================================================================================

üõ°Ô∏è Error handling prevents webhook failures from affecting payment processing
üõ°Ô∏è Graceful degradation maintains service availability during issues
üõ°Ô∏è Proper status codes ensure Stripe's retry mechanism works correctly
üõ°Ô∏è Data integrity protection prevents financial discrepancies
üõ°Ô∏è Comprehensive logging enables rapid issue diagnosis and resolution

This test validates the webhook's resilience under adverse conditions.
Production webhook endpoints must handle errors gracefully to maintain
customer trust and financial accuracy. Any failures could lead to
service outages, data corruption, or payment processing issues.