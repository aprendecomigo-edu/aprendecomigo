================================================================================
STRIPE WEBHOOK INTEGRATION VALIDATION
================================================================================

Test ID: WEBHOOK-005  
Test Name: Stripe Webhook Integration with PaymentService and Database Consistency
Test Type: Integration/End-to-End
Priority: Critical
Estimated Time: 45 minutes

================================================================================
TEST PURPOSE
================================================================================

Validate comprehensive integration between Stripe webhook handler and core services:
✅ PaymentService integration with proper method calls and responses
✅ Database consistency across PurchaseTransaction and StudentAccountBalance
✅ Model relationship integrity during webhook processing
✅ Transaction atomic operations and rollback scenarios
✅ Comprehensive audit logging throughout the payment flow
✅ Integration with existing user account and school systems
✅ End-to-end payment flow from webhook to final account state

This test ensures the webhook properly integrates with all platform components
and maintains data consistency across the entire payment processing pipeline.

================================================================================
PREREQUISITES
================================================================================

✅ Virtual environment configured (.venv directory exists)
✅ Dependencies installed (backend/requirements.txt)
✅ Test database with clean state
✅ Stripe CLI installed and configured
✅ PaymentService and related models available
✅ Test users and school data available

================================================================================
TEST PROCEDURE
================================================================================

Step 1: Environment Setup and Service Start
===========================================
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected:
✅ Django development server starts on port 8000
✅ All Django apps loaded successfully
✅ Database connections established
✅ Webhook endpoint available at /api/finances/webhooks/stripe/

Screenshot: 01-integration-environment-started.png
Duration: ~15 seconds

Step 2: Create Complete Test User Ecosystem
===========================================
Commands:
  cd backend
  # Create comprehensive test data including school relationships
  python manage.py shell -c "
from accounts.models import CustomUser, School
from finances.models import StudentAccountBalance

# Create test school
school, created = School.objects.get_or_create(
    name='Integration Test School',
    defaults={
        'email': 'admin@integrationtest.com',
        'address': '123 Test Street'
    }
)
print(f'School: {school.name} (Created: {created})')

# Create test student with school relationship
student, created = CustomUser.objects.get_or_create(
    email='integration.student@test.com',
    defaults={
        'name': 'Integration Test Student',
        'user_type': 'student'
    }
)
print(f'Student: {student.email} (Created: {created})')

# Create student account balance
balance, created = StudentAccountBalance.objects.get_or_create(
    student=student,
    defaults={
        'hours_purchased': 5.0,
        'hours_consumed': 2.0, 
        'balance_amount': 25.0
    }
)
print(f'Balance created: {created}, Hours: {balance.hours_purchased}, Amount: €{balance.balance_amount}')
"

Expected:
✅ Test school created with proper relationships
✅ Test student created with school association
✅ Student account balance initialized with existing values
✅ Database relationships properly established

Screenshot: 02-test-ecosystem-created.png

Step 3: Create Test Transaction with Rich Metadata
===================================================
Commands:
  # Create transaction with comprehensive metadata for integration testing
  python manage.py shell -c "
from accounts.models import CustomUser
from finances.models import PurchaseTransaction, TransactionType, TransactionPaymentStatus
from decimal import Decimal

student = CustomUser.objects.get(email='integration.student@test.com')

transaction = PurchaseTransaction.objects.create(
    student=student,
    transaction_type=TransactionType.PACKAGE,
    amount=Decimal('75.00'),
    payment_status=TransactionPaymentStatus.PROCESSING,
    stripe_payment_intent_id='pi_integration_test_001',
    metadata={
        'hours': '15.00',
        'package_name': '15-hour Premium Package',
        'package_type': 'premium',
        'discount_applied': '10.00',
        'promotion_code': 'INTEGRATION2024',
        'school_id': str(student.school_memberships.first().school.id if student.school_memberships.exists() else 'none'),
        'integration_test': True
    }
)

print(f'Transaction ID: {transaction.id}')
print(f'Payment Intent: {transaction.stripe_payment_intent_id}')
print(f'Amount: €{transaction.amount}')
print(f'Hours in metadata: {transaction.metadata.get(\"hours\")}')
print(f'Package type: {transaction.metadata.get(\"package_type\")}')
"

Expected:
✅ Transaction created with rich metadata structure
✅ Proper student relationship established
✅ Payment intent ID set for webhook testing
✅ Initial status set to PROCESSING

Screenshot: 03-rich-transaction-created.png

Step 4: Validate Pre-Integration Database State
===============================================
Commands:
  # Comprehensive check of database state before webhook processing
  python manage.py shell -c "
from accounts.models import CustomUser
from finances.models import PurchaseTransaction, StudentAccountBalance

student = CustomUser.objects.get(email='integration.student@test.com')
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_integration_test_001')
balance = StudentAccountBalance.objects.get(student=student)

print('=== PRE-INTEGRATION STATE ===')
print(f'Student ID: {student.id}')
print(f'Student Type: {student.user_type}') 
print(f'Transaction ID: {transaction.id}')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Transaction Amount: €{transaction.amount}')
print(f'Current Hours Balance: {balance.hours_purchased}')
print(f'Current Amount Balance: €{balance.balance_amount}')
print(f'Hours Consumed: {balance.hours_consumed}')
print(f'Expected Hours After Success: {float(balance.hours_purchased) + 15.0}')
print(f'Expected Amount After Success: {float(balance.balance_amount) + 75.0}')
"

Expected:
✅ Student properly identified with all relationships
✅ Transaction in PROCESSING state with correct amount
✅ Current balance shows existing 5.0 hours and €25.0
✅ Expected post-success state calculated correctly

Screenshot: 04-pre-integration-state-validated.png

Step 5: Test PaymentService Integration via Webhook
====================================================
Commands:
  # Trigger webhook event and monitor PaymentService integration
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_integration_test_001

Expected:
✅ Stripe CLI sends payment_intent.succeeded event
✅ Webhook handler receives and validates event
✅ PaymentService.confirm_payment_completion method called
✅ Transaction status updated atomically
✅ Student balance updated correctly
✅ HTTP 200 response sent to Stripe

Screenshot: 05-webhook-integration-triggered.png

Step 6: Verify PaymentService Method Integration
================================================
Commands:
  # Check that PaymentService methods were called correctly
  make logs | grep -i "payment.*service\|confirm.*payment" | tail -10

Expected:
✅ PaymentService initialization logged
✅ confirm_payment_completion method call logged
✅ Payment intent ID passed correctly to service
✅ Service response processed by webhook handler
✅ Integration between webhook and service successful

Screenshot: 06-payment-service-integration-verified.png

Step 7: Validate Database State After Integration
==================================================
Commands:
  # Comprehensive check of database state after webhook processing
  python manage.py shell -c "
from accounts.models import CustomUser
from finances.models import PurchaseTransaction, StudentAccountBalance

student = CustomUser.objects.get(email='integration.student@test.com')
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_integration_test_001')
balance = StudentAccountBalance.objects.get(student=student)

print('=== POST-INTEGRATION STATE ===')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Transaction Completed At: {transaction.completed_at}')
print(f'Hours Balance: {balance.hours_purchased} (Expected: 20.0)')
print(f'Amount Balance: €{balance.balance_amount} (Expected: €100.0)')
print(f'Hours Consumed: {balance.hours_consumed} (Should remain: 2.0)')

# Verify calculations
expected_hours = 5.0 + 15.0  # Original + new hours
expected_amount = 25.0 + 75.0  # Original + new amount
hours_correct = float(balance.hours_purchased) == expected_hours
amount_correct = float(balance.balance_amount) == expected_amount

print(f'Hours Calculation Correct: {hours_correct}')
print(f'Amount Calculation Correct: {amount_correct}')
print(f'Integration Success: {hours_correct and amount_correct}')
"

Expected:
✅ Transaction status changed to COMPLETED
✅ Transaction completed_at timestamp set
✅ Hours balance correctly increased to 20.0 (5.0 + 15.0)
✅ Amount balance correctly increased to €100.0 (€25.0 + €75.0)
✅ Hours consumed remained unchanged at 2.0
✅ All calculations performed correctly

Screenshot: 07-database-state-post-integration.png

Step 8: Test Model Relationship Integrity
==========================================
Commands:
  # Verify all model relationships remain intact after processing
  python manage.py shell -c "
from accounts.models import CustomUser
from finances.models import PurchaseTransaction, StudentAccountBalance

student = CustomUser.objects.get(email='integration.student@test.com')

# Check student -> transaction relationship
student_transactions = student.purchase_transactions.all()
print(f'Student has {student_transactions.count()} transactions')

# Check student -> balance relationship  
try:
    balance = student.student_balance
    print(f'Student balance accessible: Hours={balance.hours_purchased}')
except:
    print('ERROR: Student balance relationship broken')

# Check transaction -> student relationship
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_integration_test_001')
print(f'Transaction student: {transaction.student.email}')

# Verify school relationships if applicable
if student.school_memberships.exists():
    school = student.school_memberships.first().school
    print(f'Student school: {school.name}')

print('All model relationships verified successfully')
"

Expected:
✅ Student to transaction relationship intact
✅ Student to balance relationship intact
✅ Transaction to student relationship intact
✅ School relationships preserved if applicable
✅ All foreign key relationships functioning correctly

Screenshot: 08-model-relationships-verified.png

Step 9: Test Atomic Transaction Rollback Scenario
==================================================
Commands:
  # Create transaction that will fail to test rollback behavior
  python manage.py shell -c "
from finances.models import PurchaseTransaction, TransactionType, TransactionPaymentStatus
from accounts.models import CustomUser
from decimal import Decimal

student = CustomUser.objects.get(email='integration.student@test.com')

# Create transaction with invalid data to force failure
invalid_transaction = PurchaseTransaction.objects.create(
    student=student,
    transaction_type=TransactionType.PACKAGE,
    amount=Decimal('50.00'),
    payment_status=TransactionPaymentStatus.PROCESSING,
    stripe_payment_intent_id='pi_invalid_integration_test',
    metadata={
        'hours': 'invalid_hours_format',  # This should cause processing issues
        'test_rollback': True
    }
)
print(f'Created invalid transaction: {invalid_transaction.id}')
"

  # Trigger webhook with invalid transaction
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_invalid_integration_test

Expected:
✅ Webhook receives invalid transaction event
✅ PaymentService encounters error during processing
✅ Database transaction rolled back (no partial updates)
✅ HTTP 500 response indicating processing failure
✅ Original student balance remains unchanged

Screenshot: 09-atomic-rollback-tested.png

Step 10: Verify Rollback Did Not Corrupt Data
==============================================
Commands:
  # Verify rollback scenario didn't affect database integrity
  python manage.py shell -c "
from accounts.models import CustomUser
from finances.models import PurchaseTransaction, StudentAccountBalance

student = CustomUser.objects.get(email='integration.student@test.com')
balance = StudentAccountBalance.objects.get(student=student)

# Check invalid transaction status
invalid_transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_invalid_integration_test')

print('=== ROLLBACK VERIFICATION ===')
print(f'Invalid Transaction Status: {invalid_transaction.payment_status}')
print(f'Student Hours Balance: {balance.hours_purchased} (Should still be 20.0)')
print(f'Student Amount Balance: €{balance.balance_amount} (Should still be €100.0)')

# Verify successful transaction unchanged
valid_transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_integration_test_001')
print(f'Valid Transaction Status: {valid_transaction.payment_status} (Should be COMPLETED)')

rollback_success = (
    float(balance.hours_purchased) == 20.0 and
    float(balance.balance_amount) == 100.0 and
    invalid_transaction.payment_status != 'COMPLETED'
)
print(f'Rollback Protection Successful: {rollback_success}')
"

Expected:
✅ Invalid transaction did not reach COMPLETED status
✅ Student balance unchanged by failed transaction
✅ Valid transaction status remains COMPLETED
✅ Rollback protection working correctly
✅ Database integrity maintained

Screenshot: 10-rollback-integrity-verified.png

Step 11: Test Comprehensive Audit Logging
==========================================
Commands:
  # Analyze comprehensive logging throughout integration
  make logs | grep -E "(webhook|payment|integration|transaction)" | tail -30

Expected:
✅ Webhook event reception logged with event details
✅ PaymentService method calls logged
✅ Database update operations logged
✅ Transaction status changes logged
✅ Error scenarios logged with appropriate levels
✅ Integration points logged for audit trail

Screenshot: 11-comprehensive-audit-logging.png

Step 12: Test Multiple Transaction Integration
==============================================
Commands:
  # Create and process multiple transactions to test batch integrity
  python manage.py shell -c "
from finances.models import PurchaseTransaction, TransactionType, TransactionPaymentStatus
from accounts.models import CustomUser
from decimal import Decimal

student = CustomUser.objects.get(email='integration.student@test.com')

# Create multiple test transactions
for i in range(3):
    transaction = PurchaseTransaction.objects.create(
        student=student,
        transaction_type=TransactionType.PACKAGE,
        amount=Decimal('25.00'),
        payment_status=TransactionPaymentStatus.PROCESSING,
        stripe_payment_intent_id=f'pi_multi_test_{i+1}',
        metadata={
            'hours': '5.00',
            'package_name': f'5-hour Package {i+1}',
            'batch_test': True
        }
    )
    print(f'Created transaction {i+1}: {transaction.stripe_payment_intent_id}')
"

  # Process multiple transactions
  for i in {1..3}; do
    stripe trigger payment_intent.succeeded --override payment_intent:id=pi_multi_test_$i
    sleep 2
  done

Expected:
✅ Multiple transactions created successfully
✅ Each webhook event processed independently
✅ No interference between concurrent processing
✅ Database consistency maintained across all transactions

Screenshot: 12-multiple-transaction-integration.png

Step 13: Verify Final Integration State
========================================
Commands:
  # Final comprehensive verification of entire integration
  python manage.py shell -c "
from accounts.models import CustomUser
from finances.models import PurchaseTransaction, StudentAccountBalance

student = CustomUser.objects.get(email='integration.student@test.com')
balance = StudentAccountBalance.objects.get(student=student)
transactions = PurchaseTransaction.objects.filter(student=student, payment_status='COMPLETED')

print('=== FINAL INTEGRATION STATE ===')
print(f'Total Completed Transactions: {transactions.count()}')
print(f'Transaction Details:')
for t in transactions:
    hours = t.metadata.get('hours', '0')
    print(f'  {t.stripe_payment_intent_id}: €{t.amount} ({hours} hours)')

print(f'Final Hours Balance: {balance.hours_purchased}')
print(f'Final Amount Balance: €{balance.balance_amount}')

# Calculate expected totals
# Original: 5.0 hours, €25.0
# First success: +15.0 hours, +€75.0  
# Three multi tests: +15.0 hours (3 * 5.0), +€75.0 (3 * €25.0)
expected_hours = 5.0 + 15.0 + 15.0  # 35.0
expected_amount = 25.0 + 75.0 + 75.0  # €175.0

print(f'Expected Hours: {expected_hours}')
print(f'Expected Amount: €{expected_amount}')
print(f'Integration Perfect: {float(balance.hours_purchased) == expected_hours and float(balance.balance_amount) == expected_amount}')
"

Expected:
✅ All successful transactions properly processed
✅ Hours balance: 35.0 (5.0 + 15.0 + 15.0)
✅ Amount balance: €175.0 (€25.0 + €75.0 + €75.0)
✅ Perfect integration across all scenarios
✅ Database consistency maintained throughout

Screenshot: 13-final-integration-state-verified.png

Step 14: Performance and Resource Integration Test
===================================================
Commands:
  # Test integration performance under reasonable load
  python -c "
import time
import threading
import subprocess

def trigger_webhook(payment_intent_id):
    try:
        result = subprocess.run([
            'stripe', 'trigger', 'payment_intent.succeeded',
            '--override', f'payment_intent:id={payment_intent_id}'
        ], capture_output=True, text=True, timeout=30)
        print(f'Triggered {payment_intent_id}: Success')
    except Exception as e:
        print(f'Error triggering {payment_intent_id}: {e}')

print('Testing integration performance...')
start_time = time.time()

# Create multiple concurrent webhook integrations
threads = []
for i in range(5):
    # Note: These will fail due to non-existent payment intents, but test integration performance
    thread = threading.Thread(target=trigger_webhook, args=(f'pi_perf_test_{i}',))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

end_time = time.time()
print(f'Integration performance test completed in {end_time - start_time:.2f} seconds')
"

Expected:
✅ Integration handles concurrent webhook requests
✅ Performance remains acceptable under load
✅ No resource exhaustion or memory leaks
✅ System stability maintained throughout testing

Screenshot: 14-performance-integration-tested.png

================================================================================
CLEANUP
================================================================================

Commands:
  make stop

Expected:
✅ All server processes terminated cleanly
✅ Integration test data preserved for analysis
✅ System ready for next test

================================================================================
PASS/FAIL CRITERIA
================================================================================

✅ PASS: Perfect integration between webhook handler and PaymentService
✅ PASS: Database consistency maintained across all model relationships
✅ PASS: Atomic transaction processing with proper rollback protection
✅ PASS: Comprehensive audit logging throughout integration pipeline
✅ PASS: Multiple transaction processing without data corruption
✅ PASS: Model relationship integrity preserved under all scenarios
✅ PASS: Performance acceptable under reasonable integration load

❌ FAIL: PaymentService integration errors or method call failures
❌ FAIL: Database inconsistencies or model relationship corruption
❌ FAIL: Failed atomic operations or incomplete rollback protection
❌ FAIL: Missing audit trail or insufficient integration logging
❌ FAIL: Data corruption during multiple transaction processing
❌ FAIL: Performance degradation or resource exhaustion under load

================================================================================
BUSINESS CRITICAL INTEGRATION
================================================================================

🔗 This test validates the core integration between payment processing and platform
🔗 PaymentService integration ensures reliable financial transaction handling
🔗 Database consistency maintains accurate student account information
🔗 Atomic operations prevent financial discrepancies and data corruption
🔗 Audit logging provides complete transaction history for compliance

This integration test is essential for production readiness. Any failures
indicate critical issues that could result in financial losses, data corruption,
or service reliability problems. Perfect integration is required for
customer trust and business operations.