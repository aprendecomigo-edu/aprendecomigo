================================================================================
STRIPE WEBHOOK IDEMPOTENCY VALIDATION
================================================================================

Test ID: WEBHOOK-003
Test Name: Stripe Webhook Idempotency and Duplicate Event Handling
Test Type: Reliability/Integration
Priority: Critical
Estimated Time: 30 minutes

================================================================================
TEST PURPOSE
================================================================================

Validate that the Stripe webhook handler implements proper idempotency controls:
✅ Duplicate event handling without double-processing
✅ State consistency when same event received multiple times
✅ Retry safety for Stripe's automatic retry mechanism
✅ Prevention of double hour crediting or status changes
✅ Atomic transaction processing for data integrity
✅ Proper logging of duplicate event attempts

This test ensures the webhook can safely handle Stripe's retry behavior and
prevents financial discrepancies from duplicate event processing.

================================================================================
PREREQUISITES
================================================================================

✅ Virtual environment configured (.venv directory exists)
✅ Dependencies installed (backend/requirements.txt)
✅ Stripe CLI installed and configured for webhook testing
✅ Test database with clean state
✅ STRIPE_WEBHOOK_SECRET configured for signature verification

================================================================================
TEST PROCEDURE
================================================================================

Step 1: Environment Setup and Service Start
===========================================
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected:
✅ Django development server starts on port 8000
✅ Backend accessible at http://localhost:8000/api/
✅ Webhook endpoint available at /api/finances/webhooks/stripe/

Screenshot: 01-servers-started.png
Duration: ~15 seconds

Step 2: Create Test Transaction for Idempotency Testing
=======================================================
Commands:
  cd backend
  python manage.py test_stripe_webhook --create-test-data --payment-intent-id pi_test_idempotency_001

Expected:
✅ Test student created: webhook.test@aprendecomigo.com
✅ Test transaction created with payment intent: pi_test_idempotency_001
✅ Transaction status: PROCESSING
✅ Transaction amount: €50.00 with 10.00 hours metadata
✅ Student account balance: 0.00 hours, €0.00 amount

Screenshot: 02-idempotency-test-transaction-created.png

Step 3: Record Initial Database State
=====================================
Commands:
  # Capture baseline state before any webhook processing
  python manage.py shell -c "
from finances.models import PurchaseTransaction, StudentAccountBalance
from accounts.models import CustomUser

student = CustomUser.objects.get(email='webhook.test@aprendecomigo.com')
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_test_idempotency_001')
balance = StudentAccountBalance.objects.get(student=student)

print('=== INITIAL STATE ===')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Transaction ID: {transaction.id}')
print(f'Student Hours: {balance.hours_purchased}')
print(f'Student Amount: €{balance.balance_amount}')
print(f'Completed At: {transaction.completed_at}')
"

Expected:
✅ Transaction status: PROCESSING
✅ Student hours: 0.00
✅ Student amount: €0.00
✅ Completed at: None (null)

Screenshot: 03-initial-database-state.png

Step 4: Process First Payment Success Event
============================================
Commands:
  # Send first payment_intent.succeeded event
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_test_idempotency_001

Expected:
✅ Stripe CLI sends payment_intent.succeeded event to webhook
✅ Webhook processes event successfully
✅ HTTP 200 response returned to Stripe
✅ Event logged with processing details

Screenshot: 04-first-payment-event-processed.png

Step 5: Verify First Event Processing Results
==============================================
Commands:
  # Check database state after first event processing
  python manage.py shell -c "
from finances.models import PurchaseTransaction, StudentAccountBalance
from accounts.models import CustomUser

student = CustomUser.objects.get(email='webhook.test@aprendecomigo.com')
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_test_idempotency_001')
balance = StudentAccountBalance.objects.get(student=student)

print('=== AFTER FIRST EVENT ===')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Student Hours: {balance.hours_purchased}')  
print(f'Student Amount: €{balance.balance_amount}')
print(f'Completed At: {transaction.completed_at}')
print(f'Processing Count: {transaction.metadata.get(\"processing_count\", \"N/A\")}')
"

Expected:
✅ Transaction status: COMPLETED
✅ Student hours: 10.00 (credited once)
✅ Student amount: €50.00 (credited once)
✅ Completed at: timestamp set
✅ Processing successful

Screenshot: 05-first-event-results.png

Step 6: Send Duplicate Payment Success Event (Retry #1)
========================================================
Commands:
  # Simulate Stripe retry by resending the same event
  # Note: Stripe CLI will generate new event ID, but same payment_intent
  stripe trigger payment_intent.succeeded --override payment_intent:id=pi_test_idempotency_001

Expected:
✅ Webhook receives duplicate event with same payment_intent.id
✅ Idempotency check recognizes already processed transaction
✅ HTTP 200 response (idempotent success)
✅ No additional processing performed

Screenshot: 06-duplicate-event-sent.png

Step 7: Verify Idempotency After First Duplicate
=================================================
Commands:
  # Verify no double processing occurred
  python manage.py shell -c "
from finances.models import PurchaseTransaction, StudentAccountBalance
from accounts.models import CustomUser

student = CustomUser.objects.get(email='webhook.test@aprendecomigo.com')
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_test_idempotency_001')
balance = StudentAccountBalance.objects.get(student=student)

print('=== AFTER FIRST DUPLICATE ===')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Student Hours: {balance.hours_purchased}')
print(f'Student Amount: €{balance.balance_amount}')
print(f'No Double Credit: {balance.hours_purchased == 10.00}')
print(f'No Double Amount: {balance.balance_amount == 50.00}')
"

Expected:
✅ Transaction status remains: COMPLETED
✅ Student hours remains: 10.00 (NOT doubled to 20.00)
✅ Student amount remains: €50.00 (NOT doubled to €100.00)
✅ No double crediting occurred
✅ Idempotency protection working

Screenshot: 07-idempotency-verified-first-retry.png

Step 8: Send Multiple Duplicate Events (Stress Test)
=====================================================
Commands:
  # Send multiple duplicate events rapidly to test idempotency under load
  for i in {1..5}; do
    echo "Sending duplicate event #$i"
    stripe trigger payment_intent.succeeded --override payment_intent:id=pi_test_idempotency_001 &
  done
  wait
  sleep 5

Expected:
✅ Multiple duplicate events sent concurrently
✅ All events receive HTTP 200 responses
✅ Webhook handles concurrent duplicate requests
✅ No processing errors or race conditions

Screenshot: 08-multiple-duplicates-sent.png

Step 9: Verify Idempotency Under Load
======================================
Commands:
  # Verify final state after multiple duplicate events
  python manage.py shell -c "
from finances.models import PurchaseTransaction, StudentAccountBalance
from accounts.models import CustomUser

student = CustomUser.objects.get(email='webhook.test@aprendecomigo.com')
transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_test_idempotency_001')
balance = StudentAccountBalance.objects.get(student=student)

print('=== AFTER MULTIPLE DUPLICATES ===')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Student Hours: {balance.hours_purchased}')
print(f'Student Amount: €{balance.balance_amount}')
print(f'Hours Still Correct: {balance.hours_purchased == 10.00}')
print(f'Amount Still Correct: {balance.balance_amount == 50.00}')
"

Expected:
✅ Transaction status still: COMPLETED
✅ Student hours still: 10.00 (NOT multiplied)
✅ Student amount still: €50.00 (NOT multiplied)
✅ Perfect idempotency maintained under load
✅ Data integrity preserved

Screenshot: 09-idempotency-under-load-verified.png

Step 10: Test Idempotency with Failed Transactions
===================================================
Commands:
  # Create transaction for failure idempotency testing
  python manage.py test_stripe_webhook --create-test-data --payment-intent-id pi_test_idempotency_failed

  # Send failure event twice
  stripe trigger payment_intent.payment_failed --override payment_intent:id=pi_test_idempotency_failed
  sleep 2
  stripe trigger payment_intent.payment_failed --override payment_intent:id=pi_test_idempotency_failed

Expected:
✅ Failed transaction created and processed once
✅ Duplicate failure event handled idempotently
✅ Transaction status remains FAILED (not re-processed)
✅ Error metadata not duplicated or corrupted

Screenshot: 10-failure-idempotency-tested.png

Step 11: Verify Failure Idempotency Results
============================================
Commands:
  # Check failed transaction idempotency
  python manage.py shell -c "
from finances.models import PurchaseTransaction

transaction = PurchaseTransaction.objects.get(stripe_payment_intent_id='pi_test_idempotency_failed')

print('=== FAILURE IDEMPOTENCY RESULTS ===')
print(f'Transaction Status: {transaction.payment_status}')
print(f'Error Message: {transaction.metadata.get(\"error_message\", \"N/A\")}')
print(f'Processing Integrity: Transaction processed correctly once')
"

Expected:
✅ Transaction status: FAILED
✅ Error message present and not duplicated
✅ Failure handling idempotency working correctly

Screenshot: 11-failure-idempotency-verified.png

Step 12: Test Race Condition Prevention
========================================
Commands:
  # Create new transaction for race condition testing
  python manage.py test_stripe_webhook --create-test-data --payment-intent-id pi_test_race_condition

  # Send concurrent events using curl to test atomic operations
  python -c "
import requests
import threading
import json
import time

def send_webhook(payment_intent_id):
    # Note: This is a simplified test - real implementation would need proper signature
    payload = {
        'type': 'payment_intent.succeeded',
        'data': {
            'object': {
                'id': payment_intent_id,
                'status': 'succeeded'
            }
        }
    }
    try:
        response = requests.post('http://localhost:8000/api/finances/webhooks/stripe/', 
                               json=payload,
                               headers={'Content-Type': 'application/json'})
        print(f'Response: {response.status_code}')
    except Exception as e:
        print(f'Error: {e}')

# Start multiple threads simultaneously
threads = []
for i in range(3):
    thread = threading.Thread(target=send_webhook, args=('pi_test_race_condition',))
    threads.append(thread)

# Start all threads at nearly the same time
for thread in threads:
    thread.start()

for thread in threads:
    thread.join()
"

Expected:
✅ Concurrent webhook requests handled safely
✅ Database atomic operations prevent race conditions
✅ Only one successful processing per payment intent
✅ No data corruption from concurrent access

Screenshot: 12-race-condition-testing.png

Step 13: Verify Comprehensive Idempotency Logging
==================================================
Commands:
  make logs | grep -i "idempot\|duplicate\|already" | tail -10

Expected:
✅ Duplicate events logged with appropriate messages
✅ Idempotency checks logged for audit trail
✅ "Already processed" messages for duplicate events
✅ No error logs for proper idempotent handling
✅ Clear distinction between first processing and duplicates

Screenshot: 13-idempotency-logging-verified.png

Step 14: Final Database Integrity Check
========================================
Commands:
  # Final comprehensive check of all test transactions
  python manage.py shell -c "
from finances.models import PurchaseTransaction, StudentAccountBalance
from accounts.models import CustomUser

student = CustomUser.objects.get(email='webhook.test@aprendecomigo.com')
transactions = PurchaseTransaction.objects.filter(student=student)
balance = StudentAccountBalance.objects.get(student=student)

print('=== FINAL INTEGRITY CHECK ===')
print(f'Total Transactions: {transactions.count()}')
for t in transactions:
    print(f'  {t.stripe_payment_intent_id}: {t.payment_status}')

print(f'Total Hours: {balance.hours_purchased}')
print(f'Total Amount: €{balance.balance_amount}')
print(f'Expected Hours: 10.00 (from pi_test_idempotency_001 only)')
print(f'Expected Amount: €50.00 (from pi_test_idempotency_001 only)')
print(f'Integrity Check: {balance.hours_purchased == 10.00 and balance.balance_amount == 50.00}')
"

Expected:
✅ Only successful transactions credited hours/amount
✅ Failed transactions did not credit anything
✅ No double crediting despite multiple duplicate events
✅ Perfect data integrity maintained
✅ Database state consistent with business logic

Screenshot: 14-final-integrity-verified.png

================================================================================
CLEANUP
================================================================================

Commands:
  make stop

Expected:
✅ All server processes terminated cleanly
✅ Test data preserved for analysis
✅ Stripe CLI webhook forwarding stopped

================================================================================
PASS/FAIL CRITERIA
================================================================================

✅ PASS: Duplicate events handled idempotently without double processing
✅ PASS: Hour crediting occurs exactly once per successful payment
✅ PASS: Transaction status updates occur exactly once per event
✅ PASS: Database integrity maintained under concurrent duplicate events
✅ PASS: Failed transaction idempotency working correctly
✅ PASS: Race condition prevention effective with atomic operations
✅ PASS: Comprehensive logging of idempotency events for audit

❌ FAIL: Any double processing of duplicate events
❌ FAIL: Multiple hour crediting for same payment
❌ FAIL: Database corruption from concurrent event processing
❌ FAIL: Race conditions causing data inconsistency
❌ FAIL: Webhook errors or crashes from duplicate events
❌ FAIL: Missing audit trail for idempotency handling

================================================================================
CRITICAL IMPORTANCE
================================================================================

💰 Idempotency prevents financial discrepancies from Stripe retries
💰 Double crediting would result in significant revenue loss
💰 Race conditions could corrupt student account balances
💰 Proper retry handling ensures reliable payment processing
💰 Audit logging enables financial reconciliation and troubleshooting

This test validates one of the most critical aspects of payment processing.
Any failures could result in financial loss, regulatory compliance issues,
or customer trust problems. Perfect idempotency is essential for production.