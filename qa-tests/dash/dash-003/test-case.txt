QA Test Case: Backend WebSocket Integration Testing

Test ID: DASH-003
Test Name: Backend WebSocket Integration for Real-time Dashboard Updates
Purpose: Verify that the school dashboard WebSocket connection works correctly with authentication and real-time message broadcasting
Expected Result: WebSocket connection established, authenticated, and real-time messages delivered correctly

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational Platform
- Architecture: Django Channels WebSocket with Redis backend
- Authentication: JWT token-based WebSocket authentication

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo
2. Python Virtual Environment: .venv/ in project root
3. Start development servers: make dev (includes Redis and Django Channels)
4. View server logs: make logs

Test Data:
- Test Email: anapmc.carvalho@gmail.com (school admin/owner)
- School ID: 1 (default test school)
- User Role: school_owner or school_admin

WebSocket Endpoint Under Test:
- ws://localhost:8000/ws/schools/1/dashboard/
- Channel Name: school_dashboard_1
- Expected Messages: metrics_update, activity_new, invitation_status_update

Prerequisites:
- Redis server running (part of make dev)
- Django Channels configured
- WebSocket consumer implemented for school dashboard

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Authentication
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Get JWT token using authentication process:
  # Use curl or frontend to get valid JWT token

Expected: Servers running, Redis available, JWT token obtained
Screenshot: 01_environment_setup_complete.png

Step 2: Test WebSocket Connection Without Authentication
Create a simple WebSocket test script:

Commands:
  cat > websocket_test.py << 'EOF'
import asyncio
import websockets
import json

async def test_websocket_no_auth():
    try:
        async with websockets.connect("ws://localhost:8000/ws/schools/1/dashboard/") as websocket:
            print("Connected without authentication - THIS SHOULD FAIL")
            response = await websocket.recv()
            print(f"Received: {response}")
    except Exception as e:
        print(f"Connection rejected as expected: {e}")

asyncio.run(test_websocket_no_auth())
EOF

python websocket_test.py

Expected: Connection should be rejected (authentication required)
Screenshot: 02_unauthenticated_connection_rejected.png

Step 3: Test WebSocket Connection With Valid Authentication
Update the test script with authentication:

Commands:
  cat > websocket_test_auth.py << 'EOF'
import asyncio
import websockets
import json

async def test_websocket_with_auth():
    # Replace YOUR_JWT_TOKEN with actual token from Step 1
    uri = "ws://localhost:8000/ws/schools/1/dashboard/"
    headers = {"Authorization": "Bearer YOUR_JWT_TOKEN"}
    
    try:
        async with websockets.connect(uri, extra_headers=headers) as websocket:
            print("Connected successfully with authentication")
            
            # Wait for connection confirmation
            await asyncio.sleep(2)
            
            # Send a test message if the protocol supports it
            test_message = {
                "type": "ping",
                "data": {"message": "test connection"}
            }
            await websocket.send(json.dumps(test_message))
            
            # Listen for any messages for 10 seconds
            try:
                while True:
                    message = await asyncio.wait_for(websocket.recv(), timeout=10.0)
                    print(f"Received message: {message}")
            except asyncio.TimeoutError:
                print("No messages received in 10 seconds")
                
    except Exception as e:
        print(f"Connection failed: {e}")

asyncio.run(test_websocket_with_auth())
EOF

# Remember to replace YOUR_JWT_TOKEN with actual token
python websocket_test_auth.py

Expected: WebSocket connection established successfully
Screenshot: 03_authenticated_connection_established.png

Step 4: Test Invalid School ID Access
Commands:
  cat > websocket_test_invalid_school.py << 'EOF'
import asyncio
import websockets
import json

async def test_invalid_school():
    uri = "ws://localhost:8000/ws/schools/999999/dashboard/"
    headers = {"Authorization": "Bearer YOUR_JWT_TOKEN"}
    
    try:
        async with websockets.connect(uri, extra_headers=headers) as websocket:
            print("Connected to invalid school - THIS SHOULD FAIL")
    except Exception as e:
        print(f"Connection to invalid school rejected: {e}")

asyncio.run(test_invalid_school())
EOF

python websocket_test_invalid_school.py

Expected: Connection rejected for invalid school ID
Screenshot: 04_invalid_school_access_rejected.png

Step 5: Test Real-time Message Broadcasting
Create a script that listens for real-time updates:

Commands:
  cat > websocket_listener.py << 'EOF'
import asyncio
import websockets
import json
from datetime import datetime

async def listen_for_updates():
    uri = "ws://localhost:8000/ws/schools/1/dashboard/"
    headers = {"Authorization": "Bearer YOUR_JWT_TOKEN"}
    
    try:
        async with websockets.connect(uri, extra_headers=headers) as websocket:
            print(f"Connected at {datetime.now()}")
            print("Listening for real-time updates...")
            
            async for message in websocket:
                data = json.loads(message)
                print(f"[{datetime.now()}] Received: {data}")
                
                # Check message structure
                if 'type' in data and 'data' in data:
                    print(f"  Message type: {data['type']}")
                    print(f"  Message data: {data['data']}")
                else:
                    print("  Invalid message structure!")
                    
    except Exception as e:
        print(f"WebSocket error: {e}")

asyncio.run(listen_for_updates())
EOF

# Run this in background
python websocket_listener.py &
LISTENER_PID=$!

Expected: WebSocket listener running and waiting for messages
Screenshot: 05_websocket_listener_active.png

Step 6: Trigger Real-time Updates via API
In a new terminal, trigger events that should send WebSocket messages:

Commands:
  # Trigger metrics update by creating a new user or invitation
  curl -X POST http://localhost:8000/api/accounts/schools/1/invitations/ \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer YOUR_JWT_TOKEN" \
    -d '{
      "email": "newteacher@example.com",
      "role": "teacher",
      "message": "Welcome to our school!"
    }'

Expected: WebSocket listener should receive invitation-related messages
Screenshot: 06_real_time_invitation_message.png

Step 7: Test Different Message Types
Commands:
  # If you have the ability to trigger different events, test:
  # - Student registration
  # - Teacher acceptance
  # - Class creation
  # Monitor the WebSocket listener for corresponding messages

Expected: Different message types (metrics_update, activity_new, invitation_status_update) received
Screenshot: 07_different_message_types.png

Step 8: Test Multiple Concurrent Connections
Commands:
  # Start multiple WebSocket connections
  for i in {1..3}; do
    python websocket_listener.py &
    echo "Started listener $i with PID $!"
  done

  # Trigger an event and verify all connections receive the message
  curl -X POST http://localhost:8000/api/accounts/schools/1/invitations/ \
    -H "Authorization: Bearer YOUR_JWT_TOKEN" \
    -d '{...}'

Expected: All WebSocket connections receive the same broadcast message
Screenshot: 08_multiple_connections_broadcast.png

Step 9: Test Connection Resilience
Commands:
  # Test connection recovery after network interruption
  # Temporarily stop and start the Django server
  # Check if WebSocket connections handle reconnection

Expected: Connections handle interruptions gracefully
Screenshot: 09_connection_resilience_test.png

Step 10: Performance and Memory Testing
Commands:
  # Monitor server resources during WebSocket usage
  ps aux | grep python
  
  # Check Django Channels and Redis performance
  make logs

Expected: Reasonable resource usage, no memory leaks
Screenshot: 10_performance_monitoring.png

Step 11: Clean Up Test Processes
Commands:
  # Kill background processes
  kill $LISTENER_PID
  pkill -f "websocket_listener.py"
  
  # Clean up test files
  rm websocket_test*.py

Expected: All test processes terminated cleanly
Screenshot: 11_cleanup_completed.png

=== PASS/FAIL CRITERIA ===

PASS: All conditions must be met
- WebSocket connection requires authentication ✓
- Authenticated connections establish successfully ✓
- Unauthorized school access is blocked ✓
- Real-time messages broadcast correctly ✓
- Message structure follows expected format ✓
- Multiple message types supported (metrics_update, activity_new, invitation_status_update) ✓
- Multiple concurrent connections supported ✓
- Connection resilience and error handling work ✓
- Performance is acceptable under load ✓
- No memory leaks or resource issues ✓

FAIL: Any condition fails
- WebSocket accessible without authentication ✗
- Users can connect to unauthorized school channels ✗
- Real-time messages not received ✗
- Invalid message structure ✗
- Missing expected message types ✗
- Concurrent connections not supported ✗
- Poor error handling or connection issues ✗
- Performance problems or memory leaks ✗

Individual Step Criteria:
- Step 1: PASS if environment setup completes successfully
- Step 2: PASS if unauthenticated connection rejected
- Step 3: PASS if authenticated connection established
- Step 4: PASS if invalid school access blocked
- Step 5: PASS if WebSocket listener setup successfully
- Step 6: PASS if API-triggered events send WebSocket messages
- Step 7: PASS if different message types received correctly
- Step 8: PASS if multiple connections receive broadcasts
- Step 9: PASS if connections handle interruptions gracefully
- Step 10: PASS if performance and resource usage acceptable
- Step 11: PASS if cleanup completes without issues

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails