QA Test Case: Purchase History API with Consumption Tracking

Test ID: BALANCE-003
Test Name: Purchase History API Testing with Consumption Analytics
Purpose: Verify the /finances/api/student-balance/purchases/ endpoint provides detailed purchase history with consumption tracking, plan details, and expiration management
Expected Result: API returns comprehensive purchase data with accurate consumption analytics

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Feature: Student Account Balance API - Purchase History Endpoint
- API Endpoint: GET /finances/api/student-balance/purchases/
- Authentication: JWT token authentication required
- Admin Override: Supports ?email= parameter for admin users

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Data Requirements:
- Test Students: Multiple users with purchase history
- Test Packages: Active, expired, and upcoming expiration packages
- Test Subscriptions: Recurring subscription purchases
- Test Consumption: Detailed hour consumption records
- Test Plans: Various pricing plan configurations

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Service Start
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected: Both services start successfully
- Backend: http://localhost:8000 responds
- Frontend: http://localhost:8081 shows loading screen
- API accessible at http://localhost:8000/api/

Step 2: Create Test Users and Purchase Data Setup
1. Open browser to http://localhost:8000/admin/
2. Login with admin credentials
3. Create test users:
   - purchase1@test.com: "Purchase Test One"
   - purchase2@test.com: "Purchase Test Two"
   - admin@test.com: "Test Admin User" (staff=True, superuser=True)

Expected: Test users created successfully
Screenshot: 01_test_users_created.png

Step 3: Create Test Pricing Plans
1. Navigate to Pricing Plans admin section
2. Create test pricing plans:
   
   Basic Package Plan:
   - Name: "Basic Hours Package"
   - Type: package
   - Hours included: 10.00
   - Price: 80.00
   - Duration: 30 days
   
   Premium Package Plan:
   - Name: "Premium Hours Package" 
   - Type: package
   - Hours included: 25.00
   - Price: 180.00
   - Duration: 60 days
   
   Monthly Subscription Plan:
   - Name: "Monthly Unlimited"
   - Type: subscription
   - Hours included: 50.00
   - Price: 200.00
   - Duration: 30 days (recurring)

Expected: Test pricing plans created successfully
Screenshot: 02_pricing_plans_created.png

Step 4: Create Test Purchase History with Various Scenarios
1. Navigate to Purchase Transactions admin section
2. Create purchases for purchase1@test.com:
   
   Purchase 1 - Active Package:
   - Student: purchase1@test.com
   - Plan: Basic Hours Package
   - Payment status: completed
   - Amount: 80.00
   - Hours purchased: 10.00
   - Expires at: [30 days from now]
   
   Purchase 2 - Expired Package:
   - Student: purchase1@test.com
   - Plan: Premium Hours Package
   - Payment status: completed
   - Amount: 180.00
   - Hours purchased: 25.00
   - Expires at: [30 days ago]
   
   Purchase 3 - Active Subscription:
   - Student: purchase1@test.com
   - Plan: Monthly Unlimited
   - Payment status: completed
   - Amount: 200.00
   - Hours purchased: 50.00
   - Expires at: [null - recurring]
   
   Purchase 4 - Soon Expiring Package:
   - Student: purchase1@test.com
   - Plan: Basic Hours Package
   - Payment status: completed
   - Amount: 80.00
   - Hours purchased: 10.00
   - Expires at: [3 days from now]

Expected: Multiple purchase scenarios created successfully
Screenshot: 03_purchase_scenarios_created.png

Step 5: Create Hour Consumption Records
1. Navigate to Hour Consumption admin section
2. Create consumption records linked to purchases:
   
   For Active Package (Purchase 1):
   - Hours consumed: 3.50
   - Consumption date: [recent]
   - Description: "Math tutoring session"
   
   For Expired Package (Purchase 2):
   - Hours consumed: 15.00
   - Consumption date: [before expiration]
   - Description: "Science tutoring sessions"
   
   For Active Subscription (Purchase 3):
   - Hours consumed: 8.25
   - Consumption date: [recent]
   - Description: "Language tutoring"

Expected: Hour consumption records created and linked to purchases
Screenshot: 04_consumption_records_created.png

Step 6: Test Unauthenticated Access to Purchases Endpoint
1. Open browser developer tools
2. Test API call without authentication:
```javascript
fetch('http://localhost:8000/finances/api/student-balance/purchases/')
  .then(response => response.json())
  .then(data => console.log('Unauthenticated purchases:', data))
  .catch(error => console.error('Error:', error));
```

Expected:
- HTTP 401 Unauthorized response
- Error message about authentication required
- No purchase data exposed

Screenshot: 05_unauthenticated_access_denied.png

Step 7: Authenticate and Test Basic Purchases API Access
1. Navigate to http://localhost:8081/auth/signin
2. Login as purchase1@test.com
3. Get JWT token from browser storage
4. Test authenticated purchases API call:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Purchase History:', data);
    console.log('Total purchases:', data.results.length);
    console.log('Pagination info:', {
      count: data.count,
      next: data.next,
      previous: data.previous
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected Response Structure:
```json
{
  "count": 4,
  "next": null,
  "previous": null,
  "results": [
    {
      "id": 1,
      "plan_details": {
        "name": "Basic Hours Package",
        "type": "package",
        "duration_days": 30
      },
      "payment_status": "completed",
      "amount": "80.00",
      "hours_purchased": "10.00",
      "expires_at": "2024-02-01T00:00:00Z",
      "is_active": true,
      "is_expired": false,
      "consumption_summary": {
        "total_consumed": "3.50",
        "remaining_hours": "6.50",
        "consumption_percentage": 35.0
      },
      "detailed_consumptions": [...]
    }
  ]
}
```

Screenshot: 06_basic_purchases_response.png

Step 8: Test Active-Only Filter
1. Test filtering to show only active purchases:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/?active_only=true', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Active purchases only:', data.results.length);
    console.log('All active?', data.results.every(p => p.is_active === true));
    console.log('No expired packages?', data.results.every(p => p.is_expired === false));
  })
  .catch(error => console.error('Error:', error));
```

Expected:
- Only active purchases returned (should exclude expired package)
- All results have is_active: true
- All results have is_expired: false

Screenshot: 07_active_only_filter.png

Step 9: Test Include Consumption Parameter
1. Test detailed consumption data inclusion:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/?include_consumption=true', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('With detailed consumption:');
    data.results.forEach((purchase, index) => {
      console.log(`Purchase ${index + 1}:`);
      console.log('  Plan:', purchase.plan_details.name);
      console.log('  Consumption summary:', purchase.consumption_summary);
      console.log('  Detailed consumptions:', purchase.detailed_consumptions.length);
      purchase.detailed_consumptions.forEach((consumption, i) => {
        console.log(`    ${i + 1}. ${consumption.hours_consumed}h - ${consumption.description}`);
      });
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected: Detailed consumption data included in response
Screenshot: 08_include_consumption_data.png

Step 10: Test Purchase Status and Expiration Logic
1. Verify expiration status logic:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== EXPIRATION STATUS VALIDATION ===');
    data.results.forEach((purchase, index) => {
      console.log(`Purchase ${index + 1}:`);
      console.log('  Plan:', purchase.plan_details.name);
      console.log('  Expires at:', purchase.expires_at);
      console.log('  Is active:', purchase.is_active);
      console.log('  Is expired:', purchase.is_expired);
      
      if (purchase.expires_at) {
        const expiresAt = new Date(purchase.expires_at);
        const now = new Date();
        const shouldBeExpired = expiresAt < now;
        console.log('  Expiration logic correct:', purchase.is_expired === shouldBeExpired);
      } else {
        console.log('  Subscription (no expiration):', purchase.plan_details.type === 'subscription');
      }
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected: Expiration status logic working correctly
Screenshot: 09_expiration_status_validation.png

Step 11: Test Consumption Summary Calculations
1. Verify consumption percentage and remaining hours calculations:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== CONSUMPTION CALCULATIONS VALIDATION ===');
    data.results.forEach((purchase, index) => {
      console.log(`Purchase ${index + 1}:`);
      const purchased = parseFloat(purchase.hours_purchased);
      const consumed = parseFloat(purchase.consumption_summary.total_consumed);
      const remaining = parseFloat(purchase.consumption_summary.remaining_hours);
      const percentage = purchase.consumption_summary.consumption_percentage;
      
      console.log('  Hours purchased:', purchased);
      console.log('  Hours consumed:', consumed);
      console.log('  Remaining hours:', remaining);
      console.log('  Consumption %:', percentage);
      
      console.log('  Remaining calculation correct:', 
        Math.abs(remaining - (purchased - consumed)) < 0.01);
      console.log('  Percentage calculation correct:', 
        Math.abs(percentage - ((consumed / purchased) * 100)) < 0.1);
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected: All consumption calculations accurate
Screenshot: 10_consumption_calculations.png

Step 12: Test Plan Details Structure
1. Verify plan information completeness:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== PLAN DETAILS VALIDATION ===');
    data.results.forEach((purchase, index) => {
      console.log(`Purchase ${index + 1} plan details:`);
      const plan = purchase.plan_details;
      console.log('  Has name:', !!plan.name);
      console.log('  Has type:', !!plan.type);
      console.log('  Has duration:', !!plan.duration_days);
      console.log('  Type valid:', ['package', 'subscription'].includes(plan.type));
      console.log('  Structure complete:', !!(plan.name && plan.type));
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected: Complete plan details in all purchases
Screenshot: 11_plan_details_validation.png

Step 13: Test Pagination with Purchases
1. Test custom page size with purchases:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/?page_size=2', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Paginated purchases:');
    console.log('  Results returned:', data.results.length);
    console.log('  Has next page:', !!data.next);
    console.log('  Total count:', data.count);
  })
  .catch(error => console.error('Error:', error));
```

Expected: Pagination working correctly with purchases
Screenshot: 12_pagination_testing.png

Step 14: Test Combined Filters
1. Test active_only with include_consumption:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/?active_only=true&include_consumption=true', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Active purchases with consumption:');
    console.log('  Active purchases count:', data.results.length);
    console.log('  All have consumption data:', 
      data.results.every(p => p.detailed_consumptions !== undefined));
    console.log('  All are active:', 
      data.results.every(p => p.is_active === true));
  })
  .catch(error => console.error('Error:', error));
```

Expected: Combined filters working correctly
Screenshot: 13_combined_filters.png

Step 15: Test Admin Email Parameter Access
1. Login as admin user
2. Test accessing another student's purchases:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/purchases/?email=purchase1@test.com', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Admin access to purchase1 purchases:', data.results.length);
    console.log('Correct student data accessed:', 
      data.results.length > 0 // Should have purchases for this student
    );
  })
  .catch(error => console.error('Error:', error));
```

Expected: Admin can access any student's purchase data
Screenshot: 14_admin_email_access.png

Step 16: Test Empty Purchases Scenario
1. Create user with no purchases
2. Test API response:
```javascript
// Login as user with no purchases
const emptyToken = 'EMPTY_USER_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${emptyToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Empty purchases response:', {
      count: data.count,
      results_length: data.results.length,
      next: data.next,
      previous: data.previous
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected: Empty response handled gracefully
Screenshot: 15_empty_purchases_scenario.png

Step 17: Test Purchase Chronological Ordering
1. Verify purchases ordered by created_at descending:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== PURCHASE ORDERING TEST ===');
    data.results.forEach((purchase, index) => {
      console.log(`${index + 1}. ${purchase.created_at} - ${purchase.plan_details.name}`);
    });
    
    const isOrderedDescending = data.results.every((purchase, index) => {
      if (index === 0) return true;
      return new Date(data.results[index - 1].created_at) >= new Date(purchase.created_at);
    });
    
    console.log('Ordered chronologically (newest first):', isOrderedDescending);
  })
  .catch(error => console.error('Error:', error));
```

Expected: Purchases ordered newest to oldest
Screenshot: 16_chronological_ordering.png

Step 18: Test Upcoming Expiration Detection
1. Verify soon-to-expire packages are identified:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== UPCOMING EXPIRATION TEST ===');
    data.results.forEach((purchase, index) => {
      if (purchase.expires_at) {
        const expiresAt = new Date(purchase.expires_at);
        const now = new Date();
        const daysUntilExpiry = (expiresAt - now) / (1000 * 60 * 60 * 24);
        
        console.log(`Purchase ${index + 1}:`);
        console.log('  Plan:', purchase.plan_details.name);
        console.log('  Days until expiry:', Math.ceil(daysUntilExpiry));
        console.log('  Is soon expiring:', daysUntilExpiry <= 7 && daysUntilExpiry > 0);
      }
    });
  })
  .catch(error => console.error('Error:', error));
```

Expected: Soon-to-expire packages properly identified
Screenshot: 17_upcoming_expiration_detection.png

Step 19: Test Performance with Consumption Data
1. Measure API performance with detailed consumption:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
const startTime = performance.now();
fetch('http://localhost:8000/finances/api/student-balance/purchases/?include_consumption=true', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => {
    const endTime = performance.now();
    console.log(`Purchases API with consumption - Response Time: ${endTime - startTime} milliseconds`);
    return response.json();
  })
  .then(data => {
    console.log('Performance test results:');
    console.log('  Purchases loaded:', data.results.length);
    console.log('  Total consumption records:', 
      data.results.reduce((total, p) => total + p.detailed_consumptions.length, 0));
  })
  .catch(error => console.error('Error:', error));
```

Expected: Acceptable performance even with consumption data
Screenshot: 18_performance_with_consumption.png

Step 20: Comprehensive Purchase Data Validation
1. Validate complete API response structure:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE';
fetch('http://localhost:8000/finances/api/student-balance/purchases/?include_consumption=true', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== COMPREHENSIVE PURCHASE VALIDATION ===');
    
    data.results.forEach((purchase, index) => {
      console.log(`Purchase ${index + 1} validation:`);
      
      // Required fields
      console.log('  Has required fields:', !!(
        purchase.id && 
        purchase.plan_details && 
        purchase.payment_status && 
        purchase.amount &&
        purchase.hours_purchased
      ));
      
      // Proper data types
      console.log('  Proper data types:', {
        idIsNumber: typeof purchase.id === 'number',
        amountIsString: typeof purchase.amount === 'string',
        isActiveIsBoolean: typeof purchase.is_active === 'boolean',
        isExpiredIsBoolean: typeof purchase.is_expired === 'boolean'
      });
      
      // Format validation
      console.log('  Format validation:', {
        amountFormat: /^\d+\.\d{2}$/.test(purchase.amount),
        hoursFormat: /^\d+\.\d{2}$/.test(purchase.hours_purchased),
        dateFormat: !isNaN(new Date(purchase.created_at).getTime())
      });
      
      // Consumption summary structure
      if (purchase.consumption_summary) {
        console.log('  Consumption summary valid:', {
          hasTotalConsumed: !!purchase.consumption_summary.total_consumed,
          hasRemainingHours: !!purchase.consumption_summary.remaining_hours,
          hasPercentage: typeof purchase.consumption_summary.consumption_percentage === 'number'
        });
      }
    });
  })
  .catch(error => console.error('Validation error:', error));
```

Expected: All validation checks pass for purchase data
Screenshot: 19_comprehensive_validation.png

=== PASS/FAIL CRITERIA ===

PASS: API returns comprehensive purchase data with accurate consumption analytics
FAIL: Any purchase data inaccuracy OR consumption tracking failure OR expiration logic errors

Individual Step Criteria:
- Step 1-5: PASS if environment setup and test data created, FAIL if setup issues
- Step 6: PASS if unauthenticated access denied, FAIL if data exposed without auth
- Step 7: PASS if basic purchases API works with proper structure, FAIL if API fails
- Step 8: PASS if active_only filter works correctly, FAIL if filter broken
- Step 9: PASS if include_consumption parameter works, FAIL if consumption data missing
- Step 10: PASS if expiration logic correct, FAIL if expiration status wrong
- Step 11: PASS if consumption calculations accurate, FAIL if calculation errors
- Step 12: PASS if plan details complete, FAIL if missing plan information
- Step 13: PASS if pagination works with purchases, FAIL if pagination broken
- Step 14: PASS if combined filters work, FAIL if filter combination fails
- Step 15: PASS if admin email access works, FAIL if admin access denied
- Step 16: PASS if empty purchases handled properly, FAIL if errors on empty data
- Step 17: PASS if chronological ordering correct, FAIL if wrong order
- Step 18: PASS if upcoming expiration detection works, FAIL if expiration logic wrong
- Step 19: PASS if performance acceptable (<2s), FAIL if slow performance
- Step 20: PASS if all data validation passes, FAIL if validation issues

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== ADDITIONAL VERIFICATION POINTS ===

Purchase Data Structure:
- Complete purchase transaction information
- Plan details with name, type, duration
- Payment status and amount information
- Expiration dates and status flags
- Consumption summary with calculations
- Detailed consumption records (when requested)

Consumption Analytics:
- Total hours consumed calculation
- Remaining hours calculation (purchased - consumed)
- Consumption percentage calculation
- Individual consumption record tracking
- Consumption linked to specific purchases

Expiration Management:
- Active/expired status determination
- Soon-to-expire detection (within 7 days)
- Subscription vs package handling
- Expiration date null handling for subscriptions

Filter Functionality:
- active_only parameter working
- include_consumption parameter working
- Combined filter support
- Pagination with filters
- Admin email parameter override

Performance Requirements:
- Response time < 2000ms
- Efficient query handling with consumption data
- Proper database relationship optimization
- Memory usage reasonable with detailed data