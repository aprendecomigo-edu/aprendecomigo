QA Test Case: Backend Notification System Testing (Issue #107)

Test ID: BALANCE-008
Test Name: Student Balance Notification System - Backend API and Email Testing
Purpose: Verify automated low balance and package expiration notification system works correctly
Expected Result: Notifications created, emails sent, duplicate prevention working, APIs responding correctly

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Notification System (Issue #107)
- Architecture: Django backend with notification models, services, and email integration
- Focus: Backend notification creation, email sending, API endpoints

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo
2. Django development server: `make dev`
3. Backend at http://localhost:8000
4. Email service configured (SMTP or development email backend)

Test Data Requirements:
- Student user: notification.test@aprendecomigo.com
- Student with balance < 2 hours (triggers low balance alert)
- Student with package expiring within 7 days
- Valid JWT token for API authentication

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  make dev
  # Wait for Django server to start

Expected: Django development server running on port 8000
Screenshot: 01_django_server_started.png
Debug: Check `make logs` if server fails to start

Step 2: Create Test Student with Low Balance
1. Access Django admin at http://localhost:8000/admin/
2. Create student user: notification.test@aprendecomigo.com
3. Create StudentAccountBalance with remaining_hours = 1.5
4. Create active school membership for the student
5. Verify student balance is below 2 hour threshold

Expected: Test student created with 1.5 hours remaining balance
Screenshot: 02_test_student_created.png

Step 3: Test Low Balance Detection Service
Commands:
  # Test the balance monitoring service directly
  python manage.py shell
  >>> from notifications.services import BalanceMonitoringService
  >>> low_balance_students = BalanceMonitoringService.check_low_balance_students()
  >>> print(f"Found {len(low_balance_students)} students with low balance")
  >>> # Should include our test student

Expected: Service detects test student with low balance (< 2 hours)
Screenshot: 03_low_balance_detection.png

Step 4: Test Low Balance Notification Creation
Commands:
  # Create low balance notification
  >>> from accounts.models import CustomUser
  >>> from decimal import Decimal
  >>> student = CustomUser.objects.get(email='notification.test@aprendecomigo.com')
  >>> notification = BalanceMonitoringService.create_low_balance_notification(student, Decimal('1.5'))
  >>> print(f"Notification created: {notification}")
  >>> print(f"Title: {notification.title}")
  >>> print(f"Message: {notification.message}")

Expected:
- Notification object created with type "low_balance"
- Title: "Low Balance Alert"
- Message contains remaining hours (1.5) and purchase prompt
- Metadata includes balance information
Screenshot: 04_notification_created.png

Step 5: Test Duplicate Prevention
Commands:
  # Try to create another notification for same user
  >>> notification2 = BalanceMonitoringService.create_low_balance_notification(student, Decimal('1.5'))
  >>> print(f"Second notification: {notification2}")
  # Should return None due to 24h cooldown

Expected: Second notification returns None (duplicate prevention working)
Screenshot: 05_duplicate_prevention.png

Step 6: Test Low Balance Email Sending
Commands:
  # Send low balance email
  >>> email_result = BalanceMonitoringService.send_low_balance_email(student, Decimal('1.5'))
  >>> print(f"Email result: {email_result}")

Expected:
- Email result shows success: True
- Email sent to notification.test@aprendecomigo.com
- Check development email backend or SMTP logs
Screenshot: 06_email_sent.png

Step 7: Create Test Package Expiring Soon
Commands:
  # Create package expiring in 5 days
  >>> from finances.models import PurchaseTransaction, TransactionType, TransactionPaymentStatus
  >>> from django.utils import timezone
  >>> from datetime import timedelta
  >>> expires_at = timezone.now() + timedelta(days=5)
  >>> transaction = PurchaseTransaction.objects.create(
  ...     student=student,
  ...     transaction_type=TransactionType.PACKAGE,
  ...     payment_status=TransactionPaymentStatus.COMPLETED,
  ...     amount=50.00,
  ...     hours_included=10.0,
  ...     expires_at=expires_at
  ... )
  >>> print(f"Package created, expires at: {transaction.expires_at}")

Expected: Package transaction created expiring in 5 days
Screenshot: 07_package_created.png

Step 8: Test Package Expiration Detection
Commands:
  # Test expiring package detection
  >>> expiring_packages = BalanceMonitoringService.check_expiring_packages()
  >>> print(f"Found {len(expiring_packages)} expiring packages")
  >>> for pkg in expiring_packages:
  ...     print(f"Package {pkg.id} expires at {pkg.expires_at}")

Expected: Service detects the package expiring in 5 days
Screenshot: 08_expiring_packages_detected.png

Step 9: Test Package Expiring Notification Creation
Commands:
  # Create package expiring notification
  >>> notification = BalanceMonitoringService.create_package_expiring_notification(student, transaction, 5)
  >>> print(f"Expiring notification: {notification}")
  >>> print(f"Title: {notification.title}")
  >>> print(f"Message: {notification.message}")

Expected:
- Notification created with type "package_expiring"
- Title: "Package Expiring Soon"
- Message mentions 5 days until expiry
- Related transaction linked correctly
Screenshot: 09_expiring_notification_created.png

Step 10: Test Package Expiring Email
Commands:
  # Send package expiring email
  >>> email_result = BalanceMonitoringService.send_package_expiring_email(student, transaction, 5)
  >>> print(f"Expiring email result: {email_result}")

Expected:
- Email result shows success: True
- Email contains package details and expiry warning
- Email sent to student address
Screenshot: 10_expiring_email_sent.png

Step 11: Test Complete Balance Monitoring Process
Commands:
  # Run complete monitoring process
  >>> result = BalanceMonitoringService.monitor_all_balances()
  >>> print(f"Monitoring result: {result}")

Expected:
- Result shows notifications created and emails sent
- Low balance alerts processed
- Package expiring alerts processed
- No errors in processing
Screenshot: 11_complete_monitoring.png

Step 12: Test Notification API Endpoints
Commands:
  # Get JWT token for student
  curl -X POST http://localhost:8000/api/accounts/auth/signin/ \
       -H "Content-Type: application/json" \
       -d '{"email": "notification.test@aprendecomigo.com"}'
  
  # Get verification code and complete login
  # Then test notifications endpoint
  curl -H "Authorization: Token [student_token]" \
       http://localhost:8000/api/notifications/

Expected:
- API returns both low balance and package expiring notifications
- Notifications have correct structure and data
- Authentication required and working
Screenshot: 12_notifications_api.png

Step 13: Test Notification Detail API
Commands:
  # Get specific notification
  curl -H "Authorization: Token [student_token]" \
       http://localhost:8000/api/notifications/[notification_id]/

Expected:
- Returns detailed notification information
- Includes metadata and related transaction
- User can only access their own notifications
Screenshot: 13_notification_detail_api.png

Step 14: Test Unread Count API
Commands:
  # Get unread notification count
  curl -H "Authorization: Token [student_token]" \
       http://localhost:8000/api/notifications/unread-count/

Expected:
- Returns correct unread count (should be 2 for our test)
- Response format: {"unread_count": 2}
Screenshot: 14_unread_count_api.png

Step 15: Test Mark as Read API
Commands:
  # Mark notification as read
  curl -X POST -H "Authorization: Token [student_token]" \
       http://localhost:8000/api/notifications/[notification_id]/read/
  
  # Check unread count again
  curl -H "Authorization: Token [student_token]" \
       http://localhost:8000/api/notifications/unread-count/

Expected:
- Notification marked as read successfully
- Unread count decreases by 1
- Read timestamp updated
Screenshot: 15_mark_read_api.png

Step 16: Test API Security and Authorization
Commands:
  # Try accessing notifications without token
  curl http://localhost:8000/api/notifications/
  
  # Try accessing with invalid token
  curl -H "Authorization: Token invalid_token" \
       http://localhost:8000/api/notifications/

Expected:
- Unauthorized requests return 401 status
- Invalid tokens return appropriate error messages
- No data leaked to unauthorized users
Screenshot: 16_api_security.png

=== PASS/FAIL CRITERIA ===

PASS: ALL of the following conditions must be met:
1. Low balance detection service identifies students with < 2 hours correctly
2. Low balance notifications created with proper title, message, and metadata
3. Package expiration detection identifies packages expiring within 7 days
4. Package expiring notifications created with correct details
5. Email notifications sent successfully for both types
6. Duplicate prevention works (24h cooldown)
7. All notification API endpoints respond correctly
8. Authentication and authorization work properly
9. Unread count API returns accurate numbers
10. Mark as read functionality updates status correctly
11. API security prevents unauthorized access
12. Complete monitoring process runs without errors

FAIL: ANY of the following conditions:
- Balance detection service fails or returns incorrect results
- Notifications not created or have incorrect data
- Email sending fails or emails not delivered
- Duplicate notifications created within cooldown period
- Any API endpoint returns unexpected errors
- Authentication bypass or unauthorized data access
- Unread counts incorrect or not updating
- Mark as read functionality not working
- Security vulnerabilities detected
- Monitoring process crashes or produces errors

Individual Step Criteria:
- Steps 1-2: PASS if environment setup and test data created
- Steps 3-4: PASS if low balance detection and notification creation work
- Step 5: PASS if duplicate prevention working correctly
- Step 6: PASS if low balance email sent successfully
- Steps 7-9: PASS if package expiration detection and notifications work
- Step 10: PASS if package expiring email sent successfully
- Step 11: PASS if complete monitoring process works
- Steps 12-15: PASS if all API endpoints work correctly
- Step 16: PASS if API security prevents unauthorized access

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails