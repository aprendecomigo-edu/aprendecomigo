QA Test Case: Authentication and Authorization Security Testing

Test ID: BALANCE-004
Test Name: Authentication and Authorization Security for Student Balance API
Purpose: Verify comprehensive security measures for all Student Balance API endpoints including authentication requirements, authorization controls, and data protection
Expected Result: All API endpoints properly secured with robust authentication and authorization controls

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Feature: Student Account Balance API - Security Testing
- API Endpoints: 
  - GET /finances/api/student-balance/ (Summary)
  - GET /finances/api/student-balance/history/ (Transaction History)
  - GET /finances/api/student-balance/purchases/ (Purchase History)
- Authentication: JWT token authentication required
- Authorization: Role-based access control with admin overrides

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Data Requirements:
- Test Students: Multiple users with varying data sets
- Test Admin Users: Staff and superuser accounts
- Test School Admins: School-level administrative accounts
- Test Teachers: Teacher role accounts
- Security Test Scenarios: Various attack vectors and edge cases

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Service Start
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected: Both services start successfully
- Backend: http://localhost:8000 responds
- Frontend: http://localhost:8081 shows loading screen
- API accessible at http://localhost:8000/api/

Step 2: Create Test Users with Different Roles
1. Open browser to http://localhost:8000/admin/
2. Login with admin credentials
3. Create comprehensive test user set:
   
   Regular Students:
   - security-student1@test.com: "Security Student One"
   - security-student2@test.com: "Security Student Two"
   - security-student3@test.com: "Security Student Three"
   
   Administrative Users:
   - security-admin@test.com: "Security Admin" (staff=True, superuser=True)
   - security-staff@test.com: "Security Staff" (staff=True, superuser=False)
   
   School Administrators:
   - security-school-admin@test.com: "Security School Admin" (school admin role)
   
   Teachers:
   - security-teacher@test.com: "Security Teacher" (teacher role)

Expected: Comprehensive test user set created with different permission levels
Screenshot: 01_test_users_different_roles.png

Step 3: Create Test Data for Security Testing
1. Create account balances for test students:
   
   Student 1 Data:
   - Hours purchased: 15.00
   - Hours consumed: 3.00
   - Balance amount: 120.00
   - Purchase transactions: 2 completed packages
   
   Student 2 Data:
   - Hours purchased: 8.00
   - Hours consumed: 8.00
   - Balance amount: 0.00
   - Purchase transactions: 1 completed package, 1 failed
   
   Student 3 Data:
   - Hours purchased: 5.00
   - Hours consumed: 7.00
   - Balance amount: -20.00
   - Purchase transactions: 1 completed package

Expected: Test data created for security testing scenarios
Screenshot: 02_security_test_data_created.png

Step 4: Test Unauthenticated Access Denial - All Endpoints
1. Test all three endpoints without authentication:
```javascript
const endpoints = [
  'http://localhost:8000/finances/api/student-balance/',
  'http://localhost:8000/finances/api/student-balance/history/',
  'http://localhost:8000/finances/api/student-balance/purchases/'
];

endpoints.forEach((endpoint, index) => {
  fetch(endpoint)
    .then(response => {
      console.log(`Endpoint ${index + 1} (${endpoint}):`);
      console.log('  Status:', response.status);
      console.log('  Status OK?', response.status === 401);
      return response.json();
    })
    .then(data => {
      console.log('  Response:', data);
      console.log('  Has error message:', !!data.error || !!data.detail);
    })
    .catch(error => console.error('Error:', error));
});
```

Expected:
- All endpoints return HTTP 401 Unauthorized
- No financial data exposed in responses
- Clear authentication required error messages

Screenshot: 03_unauthenticated_access_all_endpoints.png

Step 5: Test Invalid Authentication Token Handling
1. Test with malformed JWT tokens:
```javascript
const invalidTokens = [
  'invalid.token.here',
  'Bearer invalid',
  'malformed_token_string',
  'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.invalid.signature',
  ''
];

const testEndpoint = 'http://localhost:8000/finances/api/student-balance/';

invalidTokens.forEach((token, index) => {
  console.log(`\n=== Testing Invalid Token ${index + 1}: "${token}" ===`);
  
  fetch(testEndpoint, {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('Status:', response.status);
    console.log('Unauthorized?', response.status === 401);
    return response.json();
  })
  .then(data => {
    console.log('Response:', data);
    console.log('No sensitive data exposed?', !data.student && !data.balance_summary);
  })
  .catch(error => console.error('Error:', error));
});
```

Expected:
- All invalid tokens rejected with HTTP 401
- No sensitive data exposed
- Proper error handling for malformed tokens

Screenshot: 04_invalid_token_handling.png

Step 6: Test Student Data Isolation
1. Authenticate as security-student1@test.com
2. Get valid JWT token
3. Test access to own and other students' data:
```javascript
const student1Token = 'STUDENT1_JWT_TOKEN_HERE';

// Test access to own data (should work)
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${student1Token}`,
    'Content-Type': 'application/json'
  }
})
.then(response => response.json())
.then(data => {
  console.log('=== STUDENT 1 ACCESSING OWN DATA ===');
  console.log('Success:', !!data.student);
  console.log('Correct student:', data.student?.email === 'security-student1@test.com');
})
.catch(error => console.error('Error:', error));

// Test attempt to access other student's data (should fail)
fetch('http://localhost:8000/finances/api/student-balance/?email=security-student2@test.com', {
  headers: {
    'Authorization': `Bearer ${student1Token}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('=== STUDENT 1 ATTEMPTING TO ACCESS STUDENT 2 DATA ===');
  console.log('Status:', response.status);
  console.log('Access denied?', response.status === 403);
  return response.json();
})
.then(data => {
  console.log('Error message:', data.error || data.detail);
  console.log('No unauthorized data?', !data.student);
})
.catch(error => console.error('Error:', error));
```

Expected:
- Student can access only their own data
- HTTP 403 Forbidden when attempting to access others' data
- Clear permission denied error messages

Screenshot: 05_student_data_isolation.png

Step 7: Test Admin Override Permissions
1. Authenticate as security-admin@test.com (superuser)
2. Test admin access to any student's data:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN_HERE';

const studentsToTest = [
  'security-student1@test.com',
  'security-student2@test.com',
  'security-student3@test.com'
];

studentsToTest.forEach((studentEmail, index) => {
  console.log(`\n=== ADMIN ACCESSING ${studentEmail} ===`);
  
  fetch(`http://localhost:8000/finances/api/student-balance/?email=${studentEmail}`, {
    headers: {
      'Authorization': `Bearer ${adminToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('Status:', response.status);
    console.log('Access granted?', response.status === 200);
    return response.json();
  })
  .then(data => {
    console.log('Correct student accessed:', data.student?.email === studentEmail);
    console.log('Has balance data:', !!data.balance_summary);
  })
  .catch(error => console.error('Error:', error));
});
```

Expected:
- Admin can access any student's data via email parameter
- All requests return HTTP 200 Success
- Correct student data returned for each request

Screenshot: 06_admin_override_permissions.png

Step 8: Test Staff vs Superuser Permissions
1. Test different admin privilege levels:
```javascript
const staffToken = 'STAFF_JWT_TOKEN_HERE'; // staff=True, superuser=False
const superuserToken = 'SUPERUSER_JWT_TOKEN_HERE'; // staff=True, superuser=True

const testEmail = 'security-student1@test.com';

// Test staff access
console.log('=== STAFF ACCESS TEST ===');
fetch(`http://localhost:8000/finances/api/student-balance/?email=${testEmail}`, {
  headers: {
    'Authorization': `Bearer ${staffToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('Staff access status:', response.status);
  console.log('Staff access granted?', response.status === 200);
  return response.json();
})
.then(data => {
  console.log('Staff got data:', !!data.student);
})
.catch(error => console.error('Staff error:', error));

// Test superuser access
console.log('\n=== SUPERUSER ACCESS TEST ===');
fetch(`http://localhost:8000/finances/api/student-balance/?email=${testEmail}`, {
  headers: {
    'Authorization': `Bearer ${superuserToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('Superuser access status:', response.status);
  console.log('Superuser access granted?', response.status === 200);
  return response.json();
})
.then(data => {
  console.log('Superuser got data:', !!data.student);
})
.catch(error => console.error('Superuser error:', error));
```

Expected: Both staff and superuser should have admin access (as per implementation)
Screenshot: 07_staff_vs_superuser_permissions.png

Step 9: Test Teacher Role Permissions
1. Authenticate as security-teacher@test.com
2. Test teacher access to student balance data:
```javascript
const teacherToken = 'TEACHER_JWT_TOKEN_HERE';

// Test teacher accessing their own data
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${teacherToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('=== TEACHER ACCESSING OWN DATA ===');
  console.log('Status:', response.status);
  return response.json();
})
.then(data => {
  console.log('Teacher has balance data:', !!data.balance_summary);
})
.catch(error => console.error('Error:', error));

// Test teacher attempting to access student data
fetch('http://localhost:8000/finances/api/student-balance/?email=security-student1@test.com', {
  headers: {
    'Authorization': `Bearer ${teacherToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('\n=== TEACHER ATTEMPTING STUDENT ACCESS ===');
  console.log('Status:', response.status);
  console.log('Access denied?', response.status === 403);
  return response.json();
})
.then(data => {
  console.log('Error message:', data.error || data.detail);
})
.catch(error => console.error('Error:', error));
```

Expected:
- Teachers can access their own balance data
- Teachers cannot access student data via email parameter
- Proper permission denial for unauthorized access

Screenshot: 08_teacher_role_permissions.png

Step 10: Test Email Parameter Validation Security
1. Test with malicious email parameter values:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN_HERE';

const maliciousEmails = [
  'nonexistent@test.com',
  'malformed-email',
  '@malformed.com',
  'test@',
  'admin@test.com; DROP TABLE users;', // SQL injection attempt
  '../../../etc/passwd', // Path traversal attempt
  '<script>alert("xss")</script>@test.com', // XSS attempt
  'test@test.com OR 1=1', // SQL injection attempt
  ''
];

maliciousEmails.forEach((email, index) => {
  console.log(`\n=== Testing Malicious Email ${index + 1}: "${email}" ===`);
  
  fetch(`http://localhost:8000/finances/api/student-balance/?email=${encodeURIComponent(email)}`, {
    headers: {
      'Authorization': `Bearer ${adminToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('Status:', response.status);
    console.log('Proper error status?', [400, 404].includes(response.status));
    return response.json();
  })
  .then(data => {
    console.log('Has error message:', !!data.error || !!data.detail);
    console.log('No sensitive data leaked:', !data.student);
  })
  .catch(error => console.error('Error:', error));
});
```

Expected:
- Invalid emails return HTTP 400 Bad Request
- Non-existent emails return HTTP 404 Not Found
- No sensitive data leaked in error responses
- Injection attempts safely handled

Screenshot: 09_email_parameter_validation.png

Step 11: Test CORS and Security Headers
1. Check response headers for security measures:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN_HERE';

fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('=== SECURITY HEADERS ANALYSIS ===');
  console.log('Status:', response.status);
  
  const headers = {};
  for (let [key, value] of response.headers) {
    headers[key] = value;
  }
  
  console.log('Headers:', headers);
  
  // Check important security headers
  console.log('\nSecurity Headers Check:');
  console.log('Content-Type:', headers['content-type']);
  console.log('X-Content-Type-Options:', headers['x-content-type-options']);
  console.log('X-Frame-Options:', headers['x-frame-options']);
  console.log('X-XSS-Protection:', headers['x-xss-protection']);
  console.log('Strict-Transport-Security:', headers['strict-transport-security']);
  console.log('Access-Control-Allow-Origin:', headers['access-control-allow-origin']);
  
  return response.json();
})
.then(data => {
  console.log('\nData received successfully');
})
.catch(error => console.error('Error:', error));
```

Expected:
- Proper Content-Type: application/json
- Security headers present where appropriate
- CORS headers configured correctly

Screenshot: 10_security_headers_analysis.png

Step 12: Test Rate Limiting and DoS Protection
1. Test rapid consecutive requests:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN_HERE';
const endpoint = 'http://localhost:8000/finances/api/student-balance/';

console.log('=== RATE LIMITING TEST ===');
console.log('Sending 20 rapid requests...');

const requests = [];
for (let i = 0; i < 20; i++) {
  const request = fetch(endpoint, {
    headers: {
      'Authorization': `Bearer ${adminToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => ({
    request: i + 1,
    status: response.status,
    timestamp: new Date().toISOString()
  }))
  .catch(error => ({
    request: i + 1,
    error: error.message,
    timestamp: new Date().toISOString()
  }));
  
  requests.push(request);
}

Promise.all(requests).then(results => {
  console.log('Results:');
  results.forEach(result => {
    console.log(`Request ${result.request}: Status ${result.status || 'ERROR'} at ${result.timestamp}`);
  });
  
  const successCount = results.filter(r => r.status === 200).length;
  const errorCount = results.filter(r => r.status !== 200).length;
  
  console.log(`\nSummary: ${successCount} successful, ${errorCount} errors`);
  console.log('Rate limiting active:', errorCount > 0);
});
```

Expected: Rate limiting may or may not be implemented; document current behavior
Screenshot: 11_rate_limiting_test.png

Step 13: Test Cross-Student Data Leakage Prevention
1. Test for any data leakage between students:
```javascript
const student1Token = 'STUDENT1_JWT_TOKEN_HERE';
const student2Token = 'STUDENT2_JWT_TOKEN_HERE';

// Get Student 1 data
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${student1Token}`,
    'Content-Type': 'application/json'
  }
})
.then(response => response.json())
.then(student1Data => {
  console.log('=== STUDENT 1 DATA ===');
  console.log('Student:', student1Data.student?.email);
  console.log('Balance:', student1Data.balance_summary?.balance_amount);
  
  // Get Student 2 data
  return fetch('http://localhost:8000/finances/api/student-balance/', {
    headers: {
      'Authorization': `Bearer ${student2Token}`,
      'Content-Type': 'application/json'
    }
  });
})
.then(response => response.json())
.then(student2Data => {
  console.log('\n=== STUDENT 2 DATA ===');
  console.log('Student:', student2Data.student?.email);
  console.log('Balance:', student2Data.balance_summary?.balance_amount);
  
  console.log('\n=== DATA ISOLATION CHECK ===');
  console.log('Different students?', 
    student1Data.student?.email !== student2Data.student?.email);
  console.log('Different balances?', 
    student1Data.balance_summary?.balance_amount !== student2Data.balance_summary?.balance_amount);
})
.catch(error => console.error('Error:', error));
```

Expected:
- Each student receives only their own data
- No cross-contamination of data
- Clear separation between user contexts

Screenshot: 12_cross_student_data_isolation.png

Step 14: Test Session and Token Expiration
1. Test with potentially expired tokens:
```javascript
// Note: This test requires an expired token - may need to wait or use a pre-expired token
const potentiallyExpiredToken = 'POTENTIALLY_EXPIRED_TOKEN_HERE';

fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${potentiallyExpiredToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('=== TOKEN EXPIRATION TEST ===');
  console.log('Status:', response.status);
  console.log('Expired token rejected?', response.status === 401);
  return response.json();
})
.then(data => {
  console.log('Error message:', data.error || data.detail);
  console.log('No data exposed:', !data.student);
})
.catch(error => console.error('Error:', error));

// Test with token from different environment (if available)
const foreignToken = 'TOKEN_FROM_DIFFERENT_ENV';

fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${foreignToken}`,
    'Content-Type': 'application/json'
  }
})
.then(response => {
  console.log('\n=== FOREIGN TOKEN TEST ===');
  console.log('Status:', response.status);
  console.log('Foreign token rejected?', response.status === 401);
  return response.json();
})
.then(data => {
  console.log('Error message:', data.error || data.detail);
})
.catch(error => console.error('Error:', error));
```

Expected:
- Expired tokens properly rejected
- Foreign tokens from other environments rejected
- Clear expiration error messages

Screenshot: 13_token_expiration_test.png

Step 15: Test Input Sanitization and Injection Prevention
1. Test various injection attack vectors:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN_HERE';

const injectionTests = [
  // SQL injection attempts
  "test@example.com' OR '1'='1",
  "test@example.com'; DROP TABLE finances_studentaccountbalance; --",
  "test@example.com UNION SELECT * FROM accounts_customuser",
  
  // NoSQL injection attempts
  "test@example.com' || this.email == 'admin@test.com",
  
  // LDAP injection attempts
  "test@example.com)(uid=*",
  
  // Command injection attempts
  "test@example.com; ls -la",
  "test@example.com && cat /etc/passwd",
  
  // XSS attempts
  "<script>alert('xss')</script>@test.com",
  "javascript:alert('xss')@test.com"
];

injectionTests.forEach((injection, index) => {
  console.log(`\n=== Injection Test ${index + 1}: ${injection} ===`);
  
  fetch(`http://localhost:8000/finances/api/student-balance/?email=${encodeURIComponent(injection)}`, {
    headers: {
      'Authorization': `Bearer ${adminToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('Status:', response.status);
    console.log('Safely handled?', [400, 404].includes(response.status));
    return response.json();
  })
  .then(data => {
    console.log('Safe error response:', !!data.error || !!data.detail);
    console.log('No code execution evidence:', !data.system_info);
  })
  .catch(error => {
    console.log('Request failed safely:', error.message);
  });
});
```

Expected:
- All injection attempts safely handled
- No code execution or data leakage
- Proper input validation and sanitization

Screenshot: 14_injection_prevention_test.png

Step 16: Test API Endpoint Consistency Security
1. Test security consistency across all three endpoints:
```javascript
const studentToken = 'STUDENT_JWT_TOKEN_HERE';
const adminToken = 'ADMIN_JWT_TOKEN_HERE';

const endpoints = [
  '/finances/api/student-balance/',
  '/finances/api/student-balance/history/',
  '/finances/api/student-balance/purchases/'
];

console.log('=== SECURITY CONSISTENCY TEST ===');

endpoints.forEach((endpoint, index) => {
  console.log(`\nTesting endpoint ${index + 1}: ${endpoint}`);
  
  // Test student access to own data
  fetch(`http://localhost:8000${endpoint}`, {
    headers: {
      'Authorization': `Bearer ${studentToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log(`  Student access status: ${response.status}`);
    console.log(`  Student access OK: ${response.status === 200}`);
    return response.json();
  })
  .then(data => {
    console.log(`  Student got data: ${!!data.results || !!data.student}`);
  })
  .catch(error => console.error(`  Student error: ${error.message}`));
  
  // Test admin access with email parameter
  fetch(`http://localhost:8000${endpoint}?email=security-student1@test.com`, {
    headers: {
      'Authorization': `Bearer ${adminToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log(`  Admin access status: ${response.status}`);
    console.log(`  Admin access OK: ${response.status === 200}`);
    return response.json();
  })
  .then(data => {
    console.log(`  Admin got data: ${!!data.results || !!data.student}`);
  })
  .catch(error => console.error(`  Admin error: ${error.message}`));
});
```

Expected:
- Consistent security behavior across all endpoints
- Same authentication and authorization rules apply
- No endpoint-specific security vulnerabilities

Screenshot: 15_endpoint_security_consistency.png

Step 17: Test Error Message Information Disclosure
1. Test that error messages don't leak sensitive information:
```javascript
const studentToken = 'STUDENT_JWT_TOKEN_HERE';

const testCases = [
  {
    name: 'Non-existent student email',
    url: 'http://localhost:8000/finances/api/student-balance/?email=nonexistent@test.com',
    token: studentToken, // Should fail with permission error
  },
  {
    name: 'Invalid email format',
    url: 'http://localhost:8000/finances/api/student-balance/?email=invalid-email',
    token: studentToken,
  },
  {
    name: 'Missing token',
    url: 'http://localhost:8000/finances/api/student-balance/',
    token: '', // No token
  },
  {
    name: 'Malformed token',
    url: 'http://localhost:8000/finances/api/student-balance/',
    token: 'malformed.token.here',
  }
];

testCases.forEach(testCase => {
  console.log(`\n=== Testing: ${testCase.name} ===`);
  
  const headers = { 'Content-Type': 'application/json' };
  if (testCase.token) {
    headers['Authorization'] = `Bearer ${testCase.token}`;
  }
  
  fetch(testCase.url, { headers })
  .then(response => {
    console.log('Status:', response.status);
    return response.json();
  })
  .then(data => {
    console.log('Error message:', data.error || data.detail);
    console.log('Generic error (good):', !data.error?.includes('database') && !data.error?.includes('table'));
    console.log('No sensitive data:', !data.student && !data.balance_summary);
    console.log('No internal paths:', !JSON.stringify(data).includes('/home/') && !JSON.stringify(data).includes('backend/'));
  })
  .catch(error => console.error('Error:', error));
});
```

Expected:
- Generic error messages that don't reveal system internals
- No database schema information leaked
- No file paths or internal structure exposed

Screenshot: 16_error_message_disclosure_test.png

Step 18: Test Concurrent Authentication Security
1. Test for race conditions and concurrent access issues:
```javascript
const tokens = [
  'STUDENT1_JWT_TOKEN_HERE',
  'STUDENT2_JWT_TOKEN_HERE', 
  'ADMIN_JWT_TOKEN_HERE'
];

console.log('=== CONCURRENT AUTHENTICATION TEST ===');

const concurrentRequests = tokens.map((token, index) => {
  return fetch('http://localhost:8000/finances/api/student-balance/', {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => response.json())
  .then(data => ({
    tokenIndex: index,
    student: data.student?.email,
    success: !!data.student,
    timestamp: new Date().toISOString()
  }))
  .catch(error => ({
    tokenIndex: index,
    error: error.message,
    timestamp: new Date().toISOString()
  }));
});

Promise.all(concurrentRequests).then(results => {
  console.log('Concurrent request results:');
  results.forEach(result => {
    if (result.success) {
      console.log(`Token ${result.tokenIndex}: SUCCESS - ${result.student} at ${result.timestamp}`);
    } else {
      console.log(`Token ${result.tokenIndex}: ERROR - ${result.error} at ${result.timestamp}`);
    }
  });
  
  // Check for proper isolation
  const studentEmails = results.filter(r => r.success).map(r => r.student);
  const uniqueStudents = [...new Set(studentEmails)];
  console.log('\nConcurrency check:');
  console.log('Unique students returned:', uniqueStudents.length);
  console.log('No cross-contamination:', uniqueStudents.length === studentEmails.length);
});
```

Expected:
- Each token returns appropriate data for its user
- No race conditions or data mixing
- Concurrent requests handled safely

Screenshot: 17_concurrent_authentication_test.png

Step 19: Test Authorization Bypass Attempts
1. Test various authorization bypass techniques:
```javascript
const studentToken = 'STUDENT_JWT_TOKEN_HERE';

const bypassAttempts = [
  // Parameter pollution
  'http://localhost:8000/finances/api/student-balance/?email=security-student1@test.com&email=admin@test.com',
  
  // Case variation
  'http://localhost:8000/finances/api/student-balance/?Email=security-student1@test.com',
  'http://localhost:8000/finances/api/student-balance/?EMAIL=security-student1@test.com',
  
  // Unicode and encoding attempts
  'http://localhost:8000/finances/api/student-balance/?email=security%2Dstudent1%40test%2Ecom',
  
  // Array notation attempts
  'http://localhost:8000/finances/api/student-balance/?email[]=security-student1@test.com',
  
  // Path traversal in parameter
  'http://localhost:8000/finances/api/student-balance/?email=../admin@test.com',
  
  // Null byte injection
  'http://localhost:8000/finances/api/student-balance/?email=security-student1@test.com%00admin@test.com'
];

bypassAttempts.forEach((url, index) => {
  console.log(`\n=== Bypass Attempt ${index + 1} ===`);
  console.log('URL:', url);
  
  fetch(url, {
    headers: {
      'Authorization': `Bearer ${studentToken}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => {
    console.log('Status:', response.status);
    console.log('Properly blocked?', response.status === 403 || response.status === 400);
    return response.json();
  })
  .then(data => {
    console.log('Has error:', !!data.error || !!data.detail);
    console.log('No unauthorized data:', !data.student || data.student.email === 'security-student1@test.com');
  })
  .catch(error => console.error('Error:', error));
});
```

Expected:
- All bypass attempts properly blocked
- No unauthorized data access
- Consistent security enforcement

Screenshot: 18_authorization_bypass_attempts.png

Step 20: Comprehensive Security Assessment Summary
1. Generate comprehensive security assessment:
```javascript
console.log('=== COMPREHENSIVE SECURITY ASSESSMENT ===');

const securityChecklist = {
  authentication: {
    unauthenticated_access_blocked: true, // From Step 4
    invalid_token_rejection: true, // From Step 5
    token_expiration_handling: true, // From Step 14
  },
  authorization: {
    student_data_isolation: true, // From Step 6
    admin_override_working: true, // From Step 7
    role_based_permissions: true, // From Steps 8-9
    email_parameter_validation: true, // From Step 10
  },
  data_protection: {
    no_cross_student_leakage: true, // From Step 13
    error_message_safety: true, // From Step 17
    input_sanitization: true, // From Step 15
  },
  security_features: {
    proper_headers: true, // From Step 11
    injection_prevention: true, // From Step 15
    concurrent_access_safety: true, // From Step 18
    bypass_attempt_blocking: true, // From Step 19
  }
};

console.log('Security Assessment Results:');
Object.keys(securityChecklist).forEach(category => {
  console.log(`\n${category.toUpperCase()}:`);
  Object.keys(securityChecklist[category]).forEach(check => {
    const status = securityChecklist[category][check] ? 'PASS' : 'FAIL';
    console.log(`  ${check}: ${status}`);
  });
});

const allChecks = Object.values(securityChecklist).flatMap(category => Object.values(category));
const passCount = allChecks.filter(check => check === true).length;
const totalChecks = allChecks.length;

console.log(`\nOVERALL SECURITY SCORE: ${passCount}/${totalChecks} (${Math.round(passCount/totalChecks*100)}%)`);

if (passCount === totalChecks) {
  console.log('SECURITY STATUS: EXCELLENT - All security checks passed');
} else if (passCount >= totalChecks * 0.8) {
  console.log('SECURITY STATUS: GOOD - Most security checks passed');
} else if (passCount >= totalChecks * 0.6) {
  console.log('SECURITY STATUS: MODERATE - Some security issues identified');
} else {
  console.log('SECURITY STATUS: POOR - Multiple security vulnerabilities found');
}
```

Expected: Comprehensive security assessment with all checks passing
Screenshot: 19_comprehensive_security_assessment.png

=== PASS/FAIL CRITERIA ===

PASS: All API endpoints properly secured with robust authentication and authorization controls
FAIL: Any security vulnerability OR authentication bypass OR authorization failure

Individual Step Criteria:
- Step 1-3: PASS if environment setup and test data created, FAIL if setup issues
- Step 4: PASS if all unauthenticated access denied, FAIL if any data exposed without auth
- Step 5: PASS if invalid tokens rejected, FAIL if malformed tokens accepted
- Step 6: PASS if student data isolation enforced, FAIL if cross-access allowed
- Step 7: PASS if admin override works correctly, FAIL if admin access denied or broken
- Step 8: PASS if staff/superuser permissions work, FAIL if privilege escalation issues
- Step 9: PASS if teacher permissions appropriate, FAIL if unauthorized teacher access
- Step 10: PASS if email validation secure, FAIL if validation bypassed
- Step 11: PASS if security headers appropriate, FAIL if missing critical headers
- Step 12: PASS if rate limiting documented, FAIL if DoS vulnerability found
- Step 13: PASS if data isolation perfect, FAIL if any cross-contamination
- Step 14: PASS if token expiration enforced, FAIL if expired tokens accepted
- Step 15: PASS if injection attempts blocked, FAIL if any injection successful
- Step 16: PASS if security consistent across endpoints, FAIL if inconsistencies
- Step 17: PASS if error messages safe, FAIL if sensitive info leaked
- Step 18: PASS if concurrent access safe, FAIL if race conditions found
- Step 19: PASS if bypass attempts blocked, FAIL if any bypass successful
- Step 20: PASS if overall security excellent, FAIL if significant vulnerabilities

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== ADDITIONAL VERIFICATION POINTS ===

Authentication Security:
- JWT token requirement enforced
- Invalid token rejection working
- Token expiration handling
- Foreign token rejection
- Malformed token handling

Authorization Controls:
- Student data isolation (own data only)
- Admin email parameter override
- Role-based permission enforcement
- Cross-student access prevention
- Privilege escalation prevention

Input Validation:
- Email format validation
- Parameter sanitization
- Injection attempt blocking
- Malicious input handling
- Unicode and encoding safety

Data Protection:
- No cross-student data leakage
- Error message information safety
- Response header security
- Session isolation
- Concurrent access safety

Attack Prevention:
- SQL injection prevention
- XSS prevention
- CSRF protection (if applicable)
- Parameter pollution handling
- Authorization bypass prevention