QA Test Case: Student Balance Summary API Testing

Test ID: BALANCE-001
Test Name: Student Balance Summary API Endpoint Testing
Purpose: Verify the /finances/api/student-balance/ endpoint provides accurate balance summaries with proper authentication, admin overrides, and comprehensive balance information
Expected Result: API returns accurate balance data with proper authentication and security controls

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Feature: Student Account Balance API - Summary Endpoint
- API Endpoint: GET /finances/api/student-balance/
- Authentication: JWT token authentication required
- Admin Override: Supports ?email= parameter for admin users

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Data Requirements:
- Test Students: Multiple users with varying balance scenarios
- Test Admin User: Superuser access for admin parameter testing
- Test Packages: Active and expired tutoring hour packages
- Test Consumptions: Various hour consumption records

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Service Start
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected: Both services start successfully
- Backend: http://localhost:8000 responds
- Frontend: http://localhost:8081 shows loading screen
- API accessible at http://localhost:8000/api/

Step 2: Create Test Users and Data via Django Admin
1. Open browser to http://localhost:8000/admin/
2. Login with admin credentials
3. Create test users:
   - student1@test.com: "Test Student One"
   - student2@test.com: "Test Student Two" 
   - student3@test.com: "Test Student Three"
   - admin@test.com: "Test Admin User" (staff=True, superuser=True)

Expected: Test users created successfully
Screenshot: 01_test_users_created.png

Step 3: Create Test Account Balances with Different Scenarios
1. Navigate to Student Account Balances admin
2. Create balance scenarios:
   
   Student 1 - Positive Balance:
   - Hours purchased: 20.00
   - Hours consumed: 5.50
   - Balance amount: 145.50
   
   Student 2 - Low Balance:
   - Hours purchased: 3.00
   - Hours consumed: 2.25
   - Balance amount: 15.00
   
   Student 3 - Overdraft:
   - Hours purchased: 5.00
   - Hours consumed: 7.50
   - Balance amount: -25.00

Expected: All test balances created successfully
Screenshot: 02_test_balances_created.png

Step 4: Test Unauthenticated API Access
1. Open browser developer tools
2. Navigate to console
3. Execute API call without authentication:
```javascript
fetch('http://localhost:8000/finances/api/student-balance/')
  .then(response => response.json())
  .then(data => console.log('Unauthenticated:', data))
  .catch(error => console.error('Error:', error));
```

Expected: 
- HTTP 401 Unauthorized response
- Error message about authentication required
- No balance data exposed

Screenshot: 03_unauthenticated_access_denied.png

Step 5: Authenticate Student User and Test API Access
1. Navigate to http://localhost:8081/auth/signin
2. Login as student1@test.com
3. Complete authentication flow
4. Navigate to http://localhost:8081/profile or dashboard
5. Open browser developer tools / Application tab
6. Find JWT token in localStorage or sessionStorage
7. Copy the token value

Expected: Authentication successful with JWT token obtained
Screenshot: 04_student_authentication_success.png

Step 6: Test Authenticated Student Balance API Call
1. In browser console, execute authenticated API call:
```javascript
const token = 'YOUR_JWT_TOKEN_HERE'; // Replace with actual token
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Student Balance Data:', data);
    console.log('Student Info:', data.student);
    console.log('Balance Summary:', data.balance_summary);
    console.log('Package Status:', data.package_status);
  })
  .catch(error => console.error('Error:', error));
```

Expected Response Structure:
```json
{
  "student": {
    "id": 1,
    "email": "student1@test.com",
    "name": "Test Student One"
  },
  "balance_summary": {
    "hours_purchased": "20.00",
    "hours_consumed": "5.50", 
    "remaining_hours": "14.50",
    "balance_amount": "145.50"
  },
  "package_status": {
    "active_packages": [...],
    "expired_packages": [...],
    "upcoming_expirations": [...]
  }
}
```

Screenshot: 05_authenticated_balance_response.png

Step 7: Test API Response Data Accuracy
1. Verify calculated remaining_hours = hours_purchased - hours_consumed
2. Check that Student 1 shows:
   - remaining_hours: 14.50 (20.00 - 5.50)
   - Positive balance_amount: 145.50
3. Verify all decimal values maintain 2-decimal precision
4. Check student information matches database

Expected: All calculations accurate, data properly formatted
Screenshot: 06_data_accuracy_verification.png

Step 8: Test Different Balance Scenarios
1. Logout from Student 1
2. Login as student2@test.com (low balance scenario)
3. Execute same API call with new token
4. Verify low balance data:
   - remaining_hours: 0.75 (3.00 - 2.25)
   - balance_amount: 15.00

Expected: Low balance scenario data accurate
Screenshot: 07_low_balance_scenario.png

Step 9: Test Overdraft Scenario
1. Logout from Student 2
2. Login as student3@test.com (overdraft scenario)
3. Execute API call
4. Verify overdraft data:
   - remaining_hours: -2.50 (5.00 - 7.50)
   - balance_amount: -25.00

Expected: Negative values handled correctly
Screenshot: 08_overdraft_scenario.png

Step 10: Test Admin Email Parameter Access - Unauthenticated
1. Logout from all student accounts
2. Test admin parameter without authentication:
```javascript
fetch('http://localhost:8000/finances/api/student-balance/?email=student1@test.com')
  .then(response => response.json())
  .then(data => console.log('Admin param unauthenticated:', data))
  .catch(error => console.error('Error:', error));
```

Expected: 
- HTTP 401 Unauthorized response
- Authentication required even with email parameter

Screenshot: 09_admin_param_unauthenticated.png

Step 11: Test Admin Email Parameter Access - Non-Admin User
1. Login as student1@test.com
2. Get authentication token
3. Test admin parameter as regular student:
```javascript
const token = 'STUDENT_JWT_TOKEN'; 
fetch('http://localhost:8000/finances/api/student-balance/?email=student2@test.com', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => console.log('Non-admin email access:', data))
  .catch(error => console.error('Error:', error));
```

Expected:
- HTTP 403 Forbidden response
- Error message: "Permission denied. Only administrators can access other students' data."

Screenshot: 10_non_admin_email_access_denied.png

Step 12: Test Admin Email Parameter Access - Valid Admin
1. Login as admin@test.com
2. Get admin authentication token
3. Test admin parameter access:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/?email=student1@test.com', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('Admin access to student1:', data);
    console.log('Accessed student:', data.student.email);
  })
  .catch(error => console.error('Error:', error));
```

Expected: 
- HTTP 200 Success response
- Student1's balance data returned
- Admin can access any student's data

Screenshot: 11_admin_email_access_success.png

Step 13: Test Invalid Email Parameter Validation
1. Test with invalid email format:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/?email=invalid-email', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => console.log('Invalid email:', data))
  .catch(error => console.error('Error:', error));
```

Expected:
- HTTP 400 Bad Request response
- Error message: "Invalid email format"

Screenshot: 12_invalid_email_validation.png

Step 14: Test Non-Existent Student Email
1. Test with valid email format but non-existent user:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/?email=nonexistent@test.com', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => console.log('Non-existent email:', data))
  .catch(error => console.error('Error:', error));
```

Expected:
- HTTP 404 Not Found response
- Error message about student not found

Screenshot: 13_nonexistent_student.png

Step 15: Test Student Without Account Balance
1. Create new test user without account balance
2. Test API access for user without balance:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/?email=student-no-balance@test.com', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => console.log('No balance student:', data))
  .catch(error => console.error('Error:', error));
```

Expected: 
- HTTP 200 Success OR appropriate handling
- Default balance values (0.00) or clear indication no balance exists

Screenshot: 14_student_no_balance.png

Step 16: Test API Performance and Response Time
1. Measure API response times:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
const startTime = performance.now();
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => {
    const endTime = performance.now();
    console.log(`API Response Time: ${endTime - startTime} milliseconds`);
    return response.json();
  })
  .then(data => console.log('Performance test:', data))
  .catch(error => console.error('Error:', error));
```

Expected: 
- Response time < 1000ms
- Acceptable performance for production use

Screenshot: 15_api_performance_test.png

Step 17: Test Concurrent API Requests
1. Test multiple simultaneous requests:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
const requests = [];
for (let i = 0; i < 5; i++) {
  requests.push(
    fetch('http://localhost:8000/finances/api/student-balance/', {
      headers: {
        'Authorization': `Bearer ${adminToken}`,
        'Content-Type': 'application/json'
      }
    })
  );
}

Promise.all(requests)
  .then(responses => Promise.all(responses.map(r => r.json())))
  .then(results => {
    console.log('Concurrent requests completed:', results.length);
    console.log('All responses consistent:', 
      results.every(r => r.student.email === results[0].student.email)
    );
  })
  .catch(error => console.error('Concurrent test error:', error));
```

Expected: 
- All requests succeed
- Consistent data across all responses
- No race conditions or data corruption

Screenshot: 16_concurrent_requests_test.png

Step 18: Test API with Expired JWT Token
1. Use an expired or invalid JWT token:
```javascript
const expiredToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.EXPIRED_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${expiredToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => console.log('Expired token:', data))
  .catch(error => console.error('Error:', error));
```

Expected:
- HTTP 401 Unauthorized response
- Proper token validation and rejection

Screenshot: 17_expired_token_test.png

Step 19: Test API Response Headers and CORS
1. Check response headers for security and CORS:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => {
    console.log('Response Headers:');
    for (let [key, value] of response.headers) {
      console.log(`${key}: ${value}`);
    }
    console.log('Status:', response.status);
    console.log('Content-Type:', response.headers.get('content-type'));
    return response.json();
  })
  .then(data => console.log('Headers test complete'))
  .catch(error => console.error('Error:', error));
```

Expected: 
- Proper Content-Type: application/json
- CORS headers if needed
- Security headers present

Screenshot: 18_response_headers_test.png

Step 20: Comprehensive Data Validation
1. Verify complete response structure:
```javascript
const adminToken = 'ADMIN_JWT_TOKEN';
fetch('http://localhost:8000/finances/api/student-balance/', {
  headers: {
    'Authorization': `Bearer ${adminToken}`,
    'Content-Type': 'application/json'
  }
})
  .then(response => response.json())
  .then(data => {
    console.log('=== COMPREHENSIVE VALIDATION ===');
    
    // Validate student object
    console.log('Student ID type:', typeof data.student.id);
    console.log('Student email format valid:', /\S+@\S+\.\S+/.test(data.student.email));
    console.log('Student name present:', !!data.student.name);
    
    // Validate balance_summary
    console.log('Hours purchased format:', /^\d+\.\d{2}$/.test(data.balance_summary.hours_purchased));
    console.log('Hours consumed format:', /^\d+\.\d{2}$/.test(data.balance_summary.hours_consumed));
    console.log('Remaining hours calculation:', 
      parseFloat(data.balance_summary.remaining_hours) === 
      parseFloat(data.balance_summary.hours_purchased) - parseFloat(data.balance_summary.hours_consumed)
    );
    console.log('Balance amount format:', /^-?\d+\.\d{2}$/.test(data.balance_summary.balance_amount));
    
    // Validate package_status structure
    console.log('Package status structure:', {
      hasActivePackages: Array.isArray(data.package_status.active_packages),
      hasExpiredPackages: Array.isArray(data.package_status.expired_packages),
      hasUpcomingExpirations: Array.isArray(data.package_status.upcoming_expirations)
    });
  })
  .catch(error => console.error('Validation error:', error));
```

Expected: All validation checks pass with proper data types and formats
Screenshot: 19_comprehensive_data_validation.png

=== PASS/FAIL CRITERIA ===

PASS: API returns accurate balance data with proper authentication and security controls
FAIL: Any authentication bypass OR incorrect data OR security vulnerability

Individual Step Criteria:
- Step 1-3: PASS if environment setup and test data created, FAIL if setup issues
- Step 4: PASS if unauthenticated access denied, FAIL if data exposed without auth
- Step 5-6: PASS if authenticated access works with proper data, FAIL if auth fails
- Step 7: PASS if data calculations accurate, FAIL if calculations wrong
- Step 8-9: PASS if different balance scenarios work correctly, FAIL if scenario errors
- Step 10-11: PASS if non-admin email access denied, FAIL if unauthorized access allowed
- Step 12: PASS if admin email access works, FAIL if admin access fails
- Step 13-14: PASS if email validation works, FAIL if invalid emails accepted
- Step 15: PASS if no-balance scenario handled, FAIL if errors or crashes
- Step 16: PASS if performance acceptable (<1s), FAIL if slow performance
- Step 17: PASS if concurrent requests stable, FAIL if race conditions
- Step 18: PASS if expired tokens rejected, FAIL if invalid tokens accepted
- Step 19: PASS if headers correct, FAIL if missing security headers
- Step 20: PASS if all data validation passes, FAIL if data format issues

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== ADDITIONAL VERIFICATION POINTS ===

API Security Checklist:
- Authentication required for all access
- Admin-only access for email parameter
- Email format validation
- Proper error messages (no data leakage)
- JWT token validation
- Rate limiting (if implemented)

Data Accuracy Checklist:
- remaining_hours = hours_purchased - hours_consumed
- Decimal precision maintained (2 decimal places)
- Negative values handled correctly (overdraft)
- Zero values handled correctly
- Student information accurate
- Balance calculations match database

Response Format Validation:
- JSON content type
- Consistent response structure
- Error responses properly formatted
- HTTP status codes appropriate
- Required fields always present
- Optional fields handled correctly

Performance Requirements:
- Response time < 1000ms under normal load
- Concurrent request handling
- Memory usage reasonable
- Database query optimization
- Proper caching if implemented