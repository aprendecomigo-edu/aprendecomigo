QA Test Case: StudentAccountBalance Model Integration

Test ID: BALANCE-002
Test Name: Model Integration Tests for StudentAccountBalance
Purpose: Verify StudentAccountBalance model integration with User model, data persistence, business logic calculations, and API accessibility
Expected Result: Model integration works correctly with proper relationships, calculations, and API access

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Feature: StudentAccountBalance model integration testing
- Model Location: backend/finances/models.py
- API Integration: Via Django REST Framework

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Data Requirements:
- Test Users: Will create multiple test users
- Database: SQLite for development testing
- API Authentication: JWT token authentication

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Service Start
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  cd backend
  make dev

Expected: Both services start successfully
- Backend: http://localhost:8000 responds
- API accessible at http://localhost:8000/api/

Step 2: Create Test Users via Django Admin
1. Open browser to http://localhost:8000/admin/
2. Login with admin credentials
3. Navigate to Users section
4. Create three test users:
   - User 1: email=student1@test.com, name="Test Student One"
   - User 2: email=student2@test.com, name="Test Student Two" 
   - User 3: email=student3@test.com, name="Test Student Three"

Expected: Three test users created successfully
Screenshot: 01_test_users_created.png

Step 3: Test One-to-One Relationship Creation
1. Navigate to Student Account Balances admin section
2. Create account balance for User 1:
   - Hours purchased: 15.00
   - Hours consumed: 3.25
   - Balance amount: 117.50
3. Save and verify creation

Expected: 
- Account balance created successfully
- Remaining hours calculated as 11.75
- One-to-one relationship established

Screenshot: 02_account_balance_created.png

Step 4: Verify Relationship Accessibility
1. Go back to Users admin section
2. Click on "Test Student One"
3. Verify account balance information is accessible (if displayed in user admin)
4. Note the relationship exists

Expected: User and account balance are properly linked
Screenshot: 03_relationship_verification.png

Step 5: Test Remaining Hours Calculation Property
1. Edit the account balance for User 1
2. Change hours_consumed to 8.50
3. Save changes
4. Verify remaining_hours recalculates to 6.50 (15.00 - 8.50)

Expected: remaining_hours property calculates correctly in real-time
Screenshot: 04_calculation_verification.png

Step 6: Test Negative Balance Scenario (Overdraft)
1. Create account balance for User 2:
   - Hours purchased: 5.00
   - Hours consumed: 7.75
   - Balance amount: -22.50
2. Save and verify

Expected:
- Account created with negative remaining hours (-2.75)
- System handles negative values correctly
- Color coding shows red for overdraft

Screenshot: 05_negative_balance_test.png

Step 7: Test Zero Balance Scenario
1. Create account balance for User 3:
   - Hours purchased: 10.00
   - Hours consumed: 10.00
   - Balance amount: 0.00
2. Save and verify

Expected:
- Account created with zero remaining hours
- System handles zero values correctly
- Appropriate color coding applied

Screenshot: 06_zero_balance_test.png

Step 8: Test Model String Representation
1. View the list of account balances in admin
2. Verify the string representation shows:
   "Account Balance for [Student Name]: €[Balance Amount] ([Remaining Hours]h remaining)"

Expected: String representation is clear and informative
Screenshot: 07_string_representation.png

Step 9: Test Decimal Precision Enforcement
1. Create/edit an account balance with high precision values:
   - Hours purchased: 12.999
   - Hours consumed: 4.555
   - Balance amount: 99.999
2. Save and refresh from database

Expected:
- Values rounded to 2 decimal places
- hours_purchased: 13.00
- hours_consumed: 4.56  
- balance_amount: 100.00

Screenshot: 08_decimal_precision.png

Step 10: Test Constraint Violation (Duplicate Account)
1. Try to create another account balance for User 1 (who already has one)
2. Fill in the form with any values
3. Attempt to save

Expected:
- Database constraint prevents creation
- Error message displayed
- Original account balance remains unchanged

Screenshot: 09_constraint_violation.png

Step 11: Test Model Ordering
1. View the list of account balances
2. Verify records are ordered by updated_at (most recent first)
3. Update one record and verify it moves to the top

Expected: Ordering works as specified in model Meta class
Screenshot: 10_model_ordering.png

Step 12: Test Cascade Deletion
1. Note the current number of account balances
2. Delete User 2 from the Users admin section
3. Return to Student Account Balances admin
4. Verify User 2's account balance was automatically deleted

Expected: Cascade deletion works - account balance deleted when user deleted
Screenshot: 11_cascade_deletion.png

Step 13: Test Large Value Handling
1. Create an account balance with maximum allowed values:
   - Hours purchased: 999.99 (max for 5 digits, 2 decimal places)
   - Hours consumed: 500.25
   - Balance amount: 9999.99 (max for 6 digits, 2 decimal places)
2. Save and verify

Expected: Large values handled correctly within field constraints
Screenshot: 12_large_values.png

Step 14: Test API Accessibility (if API endpoints exist)
1. Open browser developer tools / network tab
2. Navigate to frontend application
3. Login as a student user
4. Check for API calls related to account balance
5. Verify data structure returned

Expected: Account balance data accessible via API with proper structure
Screenshot: 13_api_accessibility.png

Step 15: Test Model Meta Properties
1. Verify model metadata through admin interface behavior:
   - Verbose name: "Student Account Balance"
   - Verbose name plural: "Student Account Balances"
   - Default ordering by -updated_at
2. Check these are reflected in admin interface

Expected: Model meta properties correctly implemented and displayed
Screenshot: 14_meta_properties.png

Step 16: Test Audit Timestamps
1. Create a new account balance
2. Note the created_at timestamp
3. Wait a few seconds
4. Edit and save the record
5. Verify updated_at timestamp changed but created_at remained the same

Expected: 
- created_at set on creation and never changes
- updated_at updates on every save
- Timestamps accurate and in correct timezone

Screenshot: 15_timestamp_verification.png

Step 17: Test Business Logic Edge Cases
1. Test very small decimal values:
   - Hours purchased: 0.01
   - Hours consumed: 0.01
   - Balance amount: 0.01
2. Test boundary values at decimal limits
3. Verify calculations remain accurate

Expected: Business logic handles edge cases correctly
Screenshot: 16_edge_cases.png

Step 18: Test Multiple Account Performance
1. Create several more account balances (5-10 accounts)
2. Navigate through the list view
3. Test search and filtering with multiple records
4. Verify performance remains acceptable

Expected: System performs well with multiple account balances
Screenshot: 17_performance_test.png

=== PASS/FAIL CRITERIA ===

PASS: All model integration features work correctly with proper relationships and business logic
FAIL: Any integration feature fails OR relationship issues OR calculation errors

Individual Step Criteria:
- Step 1-2: PASS if environment and test users created, FAIL if setup issues
- Step 3: PASS if one-to-one relationship created successfully, FAIL if relationship fails
- Step 4: PASS if relationship accessible from both sides, FAIL if relationship broken
- Step 5: PASS if remaining_hours calculation correct, FAIL if calculation wrong
- Step 6-7: PASS if negative and zero scenarios handled correctly, FAIL if errors occur
- Step 8: PASS if string representation clear and accurate, FAIL if confusing or wrong
- Step 9: PASS if decimal precision enforced, FAIL if precision not maintained
- Step 10: PASS if duplicate constraint enforced, FAIL if duplicates allowed
- Step 11: PASS if ordering works correctly, FAIL if wrong order
- Step 12: PASS if cascade deletion works, FAIL if orphaned records
- Step 13: PASS if large values handled within constraints, FAIL if overflow or errors
- Step 14: PASS if API accessible (if implemented), FAIL if API errors
- Step 15: PASS if meta properties correct, FAIL if metadata wrong
- Step 16: PASS if timestamps work correctly, FAIL if timestamp issues
- Step 17: PASS if edge cases handled properly, FAIL if edge case failures
- Step 18: PASS if performance acceptable with multiple records, FAIL if performance issues

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== ADDITIONAL VERIFICATION POINTS ===

Model Integration Checklist:
- One-to-one relationship with CustomUser properly established
- remaining_hours property calculation: hours_purchased - hours_consumed
- String representation: "Account Balance for {student.name}: €{balance_amount} ({remaining_hours}h remaining)"
- Cascade deletion: ON DELETE CASCADE for student relationship
- Decimal precision: 2 decimal places for all financial/hour fields
- Meta properties: correct verbose names and ordering
- Audit timestamps: auto_now_add for created_at, auto_now for updated_at

Business Logic Verification:
- Handles positive, negative, and zero balances correctly
- Supports overdraft scenarios (negative remaining hours)
- Maintains precision in all calculations
- Enforces database constraints properly
- Scales performance with multiple records

API Integration (if applicable):
- Account balance data accessible via REST API
- Proper serialization of decimal fields
- Relationship data included in API responses
- Authentication and permissions properly enforced