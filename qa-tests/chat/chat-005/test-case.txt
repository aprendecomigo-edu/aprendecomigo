QA Test Case: Real-time Message Sync

Test ID: CHAT-005
Test Name: Real-time Message Synchronization via WebSocket
Purpose: Verify that messages appear in real-time for all participants using WebSocket technology
Expected Result: Messages sent by one user appear instantly for other users without page refresh

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Chat Feature: Real-time messaging via Django Channels WebSocket
- WebSocket URL: ws://localhost:8000/ws/chat/{channel_name}/
- Redis Backend: Required for WebSocket channel layers

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development

Test Data:
- User A: anapmc.carvalho@gmail.com (primary test user)
- User B: Another user account in same channel
- Test Channel: Existing group channel with both users as participants

Prerequisites:
- Basic messaging works (CHAT-004 passed)
- At least one group channel with 2+ participants
- Redis server running on default port (6379)
- Backend/frontend services running
- Two browser sessions or incognito windows available for testing

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Setup Dual Browser Sessions
1. Open first browser window/tab (User A session)
2. Navigate to http://localhost:8081/chat
3. Authenticate as User A (anapmc.carvalho@gmail.com)
4. Open second browser window/incognito tab (User B session)
5. Navigate to http://localhost:8081/chat
6. Authenticate as User B (different account)

Expected: Both users successfully authenticated in separate browser sessions
Screenshot: 01_dual_sessions_setup.png

Step 2: Join Same Channel
1. In User A session, navigate to test channel
2. In User B session, navigate to same test channel
3. Verify both users see the channel open
4. Position browser windows side-by-side to monitor both
5. Check that existing messages load in both sessions

Expected: Both users viewing same channel with consistent message history
Screenshot: 02_both_users_in_channel.png

Step 3: Verify WebSocket Connection
1. Open Developer Tools in both browser sessions
2. Check Console for WebSocket connection messages
3. Look for "WebSocket connected for channel: [channel_name]"
4. Verify no WebSocket connection errors
5. Check Network tab for WebSocket connection (ws://)

Expected: WebSocket connections established successfully in both sessions
Screenshot: 03_websocket_connections.png

Step 4: Test Real-time Message from User A
1. In User A session, type message: "Teste de mensagem em tempo real - User A"
2. Send the message
3. Immediately observe User B session (do NOT refresh)
4. Verify message appears instantly in User B session
5. Check that message formatting matches in both sessions

Expected: Message appears in User B session within 1-2 seconds without refresh
Screenshot: 04_message_a_to_b_realtime.png

Step 5: Test Real-time Message from User B
1. In User B session, type message: "Resposta em tempo real - User B"
2. Send the message
3. Immediately observe User A session (do NOT refresh)
4. Verify message appears instantly in User A session
5. Check that conversation order is maintained in both sessions

Expected: Message appears in User A session within 1-2 seconds without refresh
Screenshot: 05_message_b_to_a_realtime.png

Step 6: Test Rapid Message Exchange
1. Send 3-4 messages rapidly alternating between User A and User B:
   - User A: "Mensagem rápida 1"
   - User B: "Resposta rápida 1"
   - User A: "Mensagem rápida 2"
   - User B: "Resposta rápida 2"
2. Verify all messages appear in correct order in both sessions
3. Check that no messages are lost or duplicated

Expected: All messages appear in correct chronological order in both sessions
Screenshot: 06_rapid_message_exchange.png

Step 7: Test Connection Recovery
1. Temporarily stop Redis server: redis-cli shutdown
2. Send message from User A (should fail gracefully)
3. Restart Redis server: redis-server
4. Wait for WebSocket reconnection (check console)
5. Send message from User A again
6. Verify real-time sync resumes working

Expected: Connection recovers automatically and real-time sync resumes
Screenshot: 07_connection_recovery.png

Step 8: Test Message Timestamps
1. Send message from User A
2. Verify timestamp appears immediately in User A session
3. Check that same timestamp appears in User B session
4. Confirm timestamps are consistent between sessions
5. Send message from User B and repeat verification

Expected: Timestamps consistent and accurate in both sessions
Screenshot: 08_timestamp_consistency.png

Step 9: Test Browser Console WebSocket Messages
1. Monitor console in both browser sessions
2. Send messages and observe WebSocket message events
3. Look for JSON message data in console logs
4. Verify message structure includes:
   - type: "chat_message"
   - message data with sender, content, timestamp
5. Check for any WebSocket errors or warnings

Expected: WebSocket messages logged correctly with proper structure
Screenshot: 09_websocket_console_messages.png

Step 10: Test Multiple Channel Isolation
1. Create or navigate to different channel in User A session
2. Keep User B in original channel
3. Send message in new channel from User A
4. Verify message does NOT appear in User B session (different channel)
5. Navigate User B to same new channel
6. Verify message appears when User B joins the channel

Expected: Messages only appear to users in the same channel
Screenshot: 10_channel_isolation.png

Step 11: Test User Disconnect Scenarios
1. Close User B browser tab completely
2. Send message from User A
3. Reopen User B session and navigate to channel
4. Verify message appears in User B session (from API, not WebSocket)
5. Test that real-time sync works again after reconnection

Expected: Missed messages load from API and real-time sync resumes
Screenshot: 11_disconnect_reconnect.png

Step 12: Performance and Latency Test
1. Send 10 messages rapidly from User A
2. Measure time for each message to appear in User B session
3. Verify all messages arrive within 2-3 seconds
4. Check for any performance degradation or message loss
5. Monitor system resources during heavy messaging

Expected: All messages arrive quickly with consistent performance
Screenshot: 12_performance_test.png

=== PASS/FAIL CRITERIA ===

PASS: All conditions met:
- WebSocket connections establish successfully for both users
- Messages appear in real-time (within 2-3 seconds) without page refresh
- Message order and formatting consistent between sessions
- Rapid message exchanges work without loss or duplication
- Connection recovery works when Redis/WebSocket is interrupted
- Timestamps are consistent between user sessions
- WebSocket messages have proper structure and data
- Channel isolation works (messages only in correct channels)
- Disconnect/reconnect scenarios handled gracefully
- Performance remains good with multiple rapid messages

FAIL: Any condition not met:
- WebSocket connections fail to establish
- Messages don't appear in real-time or require page refresh
- Message order or formatting inconsistent between sessions
- Messages lost or duplicated during rapid exchanges
- No connection recovery when services interrupted
- Timestamps inconsistent or incorrect between sessions
- WebSocket messages malformed or missing data
- Messages appear in wrong channels (isolation broken)
- Poor handling of disconnect/reconnect scenarios
- Performance issues or message loss during heavy usage

Individual Step Criteria:
- Step 1: PASS if both sessions authenticate, FAIL if authentication issues
- Step 2: PASS if both users see same channel, FAIL if inconsistent views
- Step 3: PASS if WebSocket connections successful, FAIL if connection errors
- Step 4: PASS if real-time delivery works A→B, FAIL if delayed or manual refresh needed
- Step 5: PASS if real-time delivery works B→A, FAIL if delayed or manual refresh needed
- Step 6: PASS if rapid exchanges work properly, FAIL if messages lost/duplicated
- Step 7: PASS if connection recovery works, FAIL if no auto-recovery
- Step 8: PASS if timestamps consistent, FAIL if timestamp mismatches
- Step 9: PASS if WebSocket data proper, FAIL if malformed or missing
- Step 10: PASS if channel isolation works, FAIL if messages leak between channels
- Step 11: PASS if disconnect/reconnect handled well, FAIL if broken after disconnect
- Step 12: PASS if performance good, FAIL if significant delays or resource issues

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== NOTES FOR TESTER ===

- This test requires two separate browser sessions - use incognito/private browsing
- Focus on timing - real-time means within seconds, not minutes
- Monitor browser console for WebSocket connection status
- Document exact timing of message delivery for performance assessment
- Pay attention to message ordering during rapid exchanges
- Test requires Redis server - ensure it's running before starting
- Use Developer Tools to monitor WebSocket traffic
- Take screenshots of both browser sessions side-by-side when possible
- Note any differences in behavior between different browsers
- Document any network or performance issues observed
