QA Test Case: Student Notification System

Test ID: EXPIRY-004
Test Name: Package Expiration Student Notification System Testing
Purpose: Verify that the student notification system correctly sends expiration warnings and confirmations, respects user preferences, and handles email delivery properly
Expected Result: Notification system sends accurate, timely emails with proper content and respects student preferences

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Architecture: Django REST backend + React Native frontend
- Feature: Package Expiration Notification System (GitHub Issue #33)
- Email Backend: Console backend for development (emails appear in server logs)

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root (NOT in backend folder)
3. Environment Variables:
   - DJANGO_ENV=development
   - EXPO_PUBLIC_ENV=development
   - Email settings configured in Django settings

Test Data Required:
- Multiple test students with different notification preferences
- Packages with various expiration dates
- Email backend configured for testing

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Service Start
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  cd backend
  python manage.py migrate
  make dev

Expected: Both services start successfully
- Backend: http://localhost:8000 responds with 401 for /api/
- Frontend: http://localhost:8081 shows loading screen

Screenshot: 01_services_started.png

Step 2: Verify Email Configuration
Commands:
  python manage.py shell

Python Shell Commands:
```python
from django.conf import settings
from django.core.mail import send_mail

# Check email backend configuration
print(f"Email Backend: {settings.EMAIL_BACKEND}")
print(f"Default From Email: {settings.DEFAULT_FROM_EMAIL}")

# Test basic email functionality
try:
    send_mail(
        subject='Test Email Configuration',
        message='This is a test email to verify configuration.',
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=['test@example.com'],
        fail_silently=False
    )
    print("Email configuration test successful")
except Exception as e:
    print(f"Email configuration error: {e}")
```

Expected Results:
- Email backend correctly configured
- Default from email set
- Test email sends without errors

Check server logs:
Commands:
  tail -10 logs/backend.log

Expected: Test email appears in server logs with correct content
Screenshot: 02_email_config_verified.png

Step 3: Create Test Students with Different Notification Preferences
Commands:
  python manage.py shell

Python Shell Commands:
```python
from django.contrib.auth import get_user_model
from finances.models import PurchaseTransaction, StudentAccountBalance, TransactionType, TransactionPaymentStatus
from decimal import Decimal
from django.utils import timezone
from datetime import timedelta

User = get_user_model()

# Student 1: Notifications enabled (default)
student1, created = User.objects.get_or_create(
    email='student.notify.enabled@example.com',
    defaults={
        'name': 'Notifications Enabled Student',
        'role': 'student',
        'metadata': {'email_notifications': True}
    }
)

# Student 2: Notifications disabled
student2, created = User.objects.get_or_create(
    email='student.notify.disabled@example.com',
    defaults={
        'name': 'Notifications Disabled Student',
        'role': 'student',
        'metadata': {'email_notifications': False}
    }
)

# Student 3: No preference set (should default to enabled)
student3, created = User.objects.get_or_create(
    email='student.notify.default@example.com',
    defaults={
        'name': 'Default Notification Student',
        'role': 'student'
    }
)

students = [student1, student2, student3]

# Create balances for all students
for student in students:
    StudentAccountBalance.objects.get_or_create(
        student=student,
        defaults={
            'hours_purchased': Decimal('15.00'),
            'balance_amount': Decimal('225.00')
        }
    )

print(f"Created test students:")
print(f"- {student1.email}: Notifications enabled")
print(f"- {student2.email}: Notifications disabled")
print(f"- {student3.email}: Default preferences")
```

Expected: Three test students created with different notification preferences
Screenshot: 03_test_students_created.png

Step 4: Create Packages for Notification Testing
Python Shell Commands:
```python
# Packages expiring in different timeframes
packages_data = [
    # Student 1 - Notifications enabled
    {
        'student': student1,
        'expires_in_days': 2,  # Urgent
        'amount': Decimal('60.00'),
        'hours': 5.0
    },
    {
        'student': student1,
        'expires_in_days': 7,  # Standard warning
        'amount': Decimal('80.00'),
        'hours': 6.0
    },
    # Student 2 - Notifications disabled
    {
        'student': student2,
        'expires_in_days': 3,  # Should not send notification
        'amount': Decimal('70.00'),
        'hours': 5.5
    },
    # Student 3 - Default preferences
    {
        'student': student3,
        'expires_in_days': 5,  # Should send notification
        'amount': Decimal('90.00'),
        'hours': 7.0
    },
    # Already expired packages for confirmation notifications
    {
        'student': student1,
        'expires_in_days': -2,  # Expired 2 days ago
        'amount': Decimal('100.00'),
        'hours': 8.0
    }
]

created_packages = []
for pkg_data in packages_data:
    expires_at = timezone.now() + timedelta(days=pkg_data['expires_in_days'])
    
    package = PurchaseTransaction.objects.create(
        student=pkg_data['student'],
        transaction_type=TransactionType.PACKAGE,
        payment_status=TransactionPaymentStatus.COMPLETED,
        amount=pkg_data['amount'],
        expires_at=expires_at,
        metadata={'hours_included': pkg_data['hours']}
    )
    created_packages.append(package)
    
    status = "expired" if pkg_data['expires_in_days'] < 0 else f"expires in {pkg_data['expires_in_days']} days"
    print(f"Package {package.id}: {pkg_data['student'].name} - â‚¬{pkg_data['amount']} - {status}")

print(f"\nTotal packages created: {len(created_packages)}")
```

Expected: Multiple packages created with various expiration dates
Screenshot: 04_notification_test_packages_created.png

Step 5: Test Expiration Warning Notifications
Python Shell Commands:
```python
from finances.services.package_expiration_service import PackageExpirationService

# Test individual notification sending
print("Testing individual expiration warnings...")

# Get packages expiring soon
expiring_packages = PackageExpirationService.get_packages_expiring_soon(days_ahead=7)
print(f"Found {len(expiring_packages)} packages expiring within 7 days")

for package in expiring_packages:
    days_until_expiry = (package.expires_at.date() - timezone.now().date()).days
    print(f"Package {package.id}: {package.student.name} - expires in {days_until_expiry} days")
    
    # Send warning notification
    result = PackageExpirationService.send_expiration_warning(
        package=package,
        days_until_expiry=days_until_expiry,
        respect_preferences=True
    )
    
    print(f"  Notification result: {result.success}")
    print(f"  Message: {result.message}")
    print(f"  Recipient: {result.recipient}")
    if result.sent_at:
        print(f"  Sent at: {result.sent_at}")
```

Expected Results:
- Notifications sent to students with enabled preferences
- Notifications NOT sent to students with disabled preferences
- Proper success/failure status for each attempt

Check server logs for email content:
Commands:
  tail -50 logs/backend.log | grep -A 15 -B 5 "Package Expiring Soon"

Expected Log Content:
- Email subject: "Package Expiring Soon - X Days Remaining"
- Email content mentions package amount, expiry date, and student name
- Only emails for students with notifications enabled

Screenshot: 05_individual_warnings_sent.png

Step 6: Test Batch Notification Sending
Python Shell Commands:
```python
# Test batch notification sending
print("Testing batch expiration warnings...")

# Send batch notifications for packages expiring within 7 days
batch_results = PackageExpirationService.send_batch_expiration_warnings(
    packages=expiring_packages,
    days_until_expiry=7
)

print(f"Batch notification results: {len(batch_results)} notifications processed")

successful_notifications = [r for r in batch_results if r.success]
failed_notifications = [r for r in batch_results if not r.success]

print(f"Successful: {len(successful_notifications)}")
print(f"Failed: {len(failed_notifications)}")

print("\nDetailed results:")
for result in batch_results:
    print(f"  {result.recipient}: {'SUCCESS' if result.success else 'FAILED'} - {result.message}")
```

Expected Results:
- Batch processing handles multiple packages efficiently
- Results show correct success/failure counts
- Failed notifications are for students with disabled preferences

Screenshot: 06_batch_notifications_processed.png

Step 7: Test Notification Preferences Override
Python Shell Commands:
```python
# Test sending notification ignoring preferences
print("Testing notification preference override...")

# Get student with disabled notifications
disabled_student = User.objects.get(email='student.notify.disabled@example.com')
disabled_packages = [pkg for pkg in expiring_packages if pkg.student == disabled_student]

if disabled_packages:
    package = disabled_packages[0]
    
    # Send with respect_preferences=True (should fail)
    result_respect = PackageExpirationService.send_expiration_warning(
        package=package,
        days_until_expiry=3,
        respect_preferences=True
    )
    print(f"With preferences respected: {result_respect.success} - {result_respect.message}")
    
    # Send with respect_preferences=False (should succeed)
    result_override = PackageExpirationService.send_expiration_warning(
        package=package,
        days_until_expiry=3,
        respect_preferences=False
    )
    print(f"With preferences overridden: {result_override.success} - {result_override.message}")
else:
    print("No packages found for disabled notification student")
```

Expected Results:
- Notifications respect preferences when respect_preferences=True
- Notifications send regardless of preferences when respect_preferences=False
- Proper success/failure status for each scenario

Screenshot: 07_notification_preferences_tested.png

Step 8: Test Expiration Confirmation Notifications
Python Shell Commands:
```python
# Test confirmation notifications after package expiration
print("Testing expiration confirmation notifications...")

# Get expired packages
expired_packages = [pkg for pkg in created_packages if pkg.expires_at < timezone.now()]
print(f"Found {len(expired_packages)} expired packages")

for package in expired_packages:
    # Calculate hours that would be expired
    hours_expired = PackageExpirationService.calculate_hours_to_expire(package)
    
    print(f"Package {package.id}: {package.student.name} - {hours_expired} hours to expire")
    
    # Send confirmation notification
    result = PackageExpirationService.send_expiration_confirmation(
        package=package,
        hours_expired=hours_expired
    )
    
    print(f"  Confirmation sent: {result.success}")
    print(f"  Message: {result.message}")
```

Check server logs for confirmation emails:
Commands:
  tail -30 logs/backend.log | grep -A 10 -B 5 "Package Expired"

Expected Log Content:
- Email subject: "Package Expired - Hours Removed from Account"
- Email content mentions hours expired and package details
- Professional tone encouraging new package purchase

Screenshot: 08_confirmation_notifications_sent.png

Step 9: Test Email Content Accuracy and Formatting
Python Shell Commands:
```python
# Test email content generation with specific data
print("Testing email content accuracy...")

test_package = expiring_packages[0]
student = test_package.student
days_until_expiry = 5

print(f"Testing email for: {student.name} ({student.email})")
print(f"Package: â‚¬{test_package.amount}, expires in {days_until_expiry} days")

# Send test notification and capture details
result = PackageExpirationService.send_expiration_warning(
    package=test_package,
    days_until_expiry=days_until_expiry,
    respect_preferences=True
)

print(f"Notification sent: {result.success}")
```

Commands:
  # Extract the most recent email from logs
  tail -100 logs/backend.log | grep -A 20 "Package Expiring Soon" | tail -20

Expected Email Content Verification:
- Subject line includes correct days remaining
- Student name is personalized correctly
- Package amount is formatted properly (â‚¬X.XX format)
- Expiry date is formatted correctly
- Professional tone and branding
- Clear call-to-action about extending/purchasing

Screenshot: 09_email_content_verified.png

Step 10: Test Notification Error Handling
Python Shell Commands:
```python
# Test error handling scenarios
print("Testing notification error handling...")

# Test with invalid student email (simulated by temporarily modifying)
test_student = User.objects.get(email='student.notify.enabled@example.com')
original_email = test_student.email

try:
    # Temporarily set invalid email format
    test_student.email = 'invalid-email-format'
    test_student.save()
    
    test_package = [pkg for pkg in expiring_packages if pkg.student == test_student][0]
    
    # Attempt to send notification
    result = PackageExpirationService.send_expiration_warning(
        package=test_package,
        days_until_expiry=5,
        respect_preferences=True
    )
    
    print(f"Invalid email test - Success: {result.success}")
    print(f"Error message: {result.message}")
    
finally:
    # Restore original email
    test_student.email = original_email
    test_student.save()

# Test with missing package metadata
print("\nTesting with incomplete package data...")
test_package_incomplete = PurchaseTransaction.objects.create(
    student=test_student,
    transaction_type=TransactionType.PACKAGE,
    payment_status=TransactionPaymentStatus.COMPLETED,
    amount=Decimal('50.00'),
    expires_at=timezone.now() + timedelta(days=3),
    metadata={}  # Missing hours_included
)

result_incomplete = PackageExpirationService.send_expiration_warning(
    package=test_package_incomplete,
    days_until_expiry=3,
    respect_preferences=True
)

print(f"Incomplete data test - Success: {result_incomplete.success}")
print(f"Message: {result_incomplete.message}")
```

Expected Results:
- Invalid email addresses handled gracefully with error messages
- Missing metadata doesn't crash the system
- All error conditions return proper failure status
- Error messages are descriptive and helpful

Screenshot: 10_error_handling_tested.png

Step 11: Test Notification Timing and Scheduling
Python Shell Commands:
```python
# Test notification timing logic
print("Testing notification timing logic...")

# Create packages with precise expiry times for timing tests
timing_test_packages = []

# Package expiring in exactly 7 days
exactly_7_days = PurchaseTransaction.objects.create(
    student=student1,
    transaction_type=TransactionType.PACKAGE,
    payment_status=TransactionPaymentStatus.COMPLETED,
    amount=Decimal('75.00'),
    expires_at=timezone.now() + timedelta(days=7, hours=0, minutes=0),
    metadata={'hours_included': 6.0}
)

# Package expiring in 6 days, 23 hours
almost_7_days = PurchaseTransaction.objects.create(
    student=student1,
    transaction_type=TransactionType.PACKAGE,
    payment_status=TransactionPaymentStatus.COMPLETED,
    amount=Decimal('75.00'),
    expires_at=timezone.now() + timedelta(days=6, hours=23, minutes=0),
    metadata={'hours_included': 6.0}
)

# Package expiring in 7 days, 1 hour
just_over_7_days = PurchaseTransaction.objects.create(
    student=student1,
    transaction_type=TransactionType.PACKAGE,
    payment_status=TransactionPaymentStatus.COMPLETED,
    amount=Decimal('75.00'),
    expires_at=timezone.now() + timedelta(days=7, hours=1, minutes=0),
    metadata={'hours_included': 6.0}
)

timing_packages = [exactly_7_days, almost_7_days, just_over_7_days]

# Test 7-day notification window
packages_7_days = PackageExpirationService.get_packages_expiring_soon(days_ahead=7)
timing_package_ids = {pkg.id for pkg in timing_packages}
found_timing_packages = [pkg for pkg in packages_7_days if pkg.id in timing_package_ids]

print(f"Packages created for timing test: {len(timing_packages)}")
print(f"Packages found in 7-day window: {len(found_timing_packages)}")

for pkg in timing_packages:
    found = pkg in packages_7_days
    days_diff = (pkg.expires_at - timezone.now()).days
    hours_diff = (pkg.expires_at - timezone.now()).total_seconds() / 3600
    print(f"Package {pkg.id}: {days_diff} days, {hours_diff:.1f} hours - Found: {found}")
```

Expected Results:
- Packages expiring in exactly 7 days are included
- Packages expiring in less than 7 days are included
- Packages expiring in more than 7 days are excluded
- Timing calculations are accurate to the hour

Screenshot: 11_notification_timing_tested.png

Step 12: Test Integration with Management Command
Commands:
  python manage.py process_package_expiration --send-notifications --notification-days=7 --verbosity=2

Expected Output:
- Command finds expiring packages correctly
- Sends notifications to appropriate students
- Respects notification preferences
- Provides detailed output of notification results

Verification:
Commands:
  tail -50 logs/backend.log | grep -c "Package Expiring Soon"

Expected: Count matches number of students with notifications enabled and expiring packages
Screenshot: 12_management_command_integration.png

Step 13: Test Notification Deduplication and Frequency
Python Shell Commands:
```python
# Test that notifications aren't sent multiple times inappropriately
print("Testing notification deduplication...")

# Send notification to same package multiple times
test_package = expiring_packages[0]
if test_package.student.metadata.get('email_notifications', True):
    
    # Send first notification
    result1 = PackageExpirationService.send_expiration_warning(
        package=test_package,
        days_until_expiry=5,
        respect_preferences=True
    )
    print(f"First notification: {result1.success}")
    
    # Send second notification immediately (should succeed - no built-in deduplication)
    result2 = PackageExpirationService.send_expiration_warning(
        package=test_package,
        days_until_expiry=5,
        respect_preferences=True
    )
    print(f"Second notification: {result2.success}")
    
    # Note: The service doesn't implement deduplication by design
    # This allows for manual admin notifications and system flexibility
    print("Service allows multiple notifications by design for admin flexibility")
```

Expected Results:
- Service allows multiple notifications (by design)
- Each notification attempt is independent
- No built-in deduplication (allows admin control)

Screenshot: 13_notification_frequency_tested.png

Step 14: Clean Up Test Data
Commands:
```python
python manage.py shell
from django.contrib.auth import get_user_model
from finances.models import PurchaseTransaction, StudentAccountBalance

User = get_user_model()

# Clean up notification test data
test_emails = [
    'student.notify.enabled@example.com',
    'student.notify.disabled@example.com',
    'student.notify.default@example.com'
]

for email in test_emails:
    try:
        user = User.objects.get(email=email)
        PurchaseTransaction.objects.filter(student=user).delete()
        StudentAccountBalance.objects.filter(student=user).delete()
        user.delete()
        print(f"Cleaned up: {email}")
    except User.DoesNotExist:
        pass

print("All notification test data cleaned up successfully")
```

Expected: All test data removed cleanly
Screenshot: 14_notification_cleanup_completed.png

=== PASS/FAIL CRITERIA ===

PASS: All notification functionality works correctly with proper preference handling
FAIL: Any notification fails OR preferences not respected OR email content incorrect

Individual Step Criteria:
- Step 1: PASS if services start, FAIL if startup fails
- Step 2: PASS if email configuration works, FAIL if email system broken
- Step 3: PASS if test students created with preferences, FAIL if creation fails
- Step 4: PASS if test packages created, FAIL if package creation fails
- Step 5: PASS if individual warnings work and respect preferences, FAIL if notifications fail
- Step 6: PASS if batch processing works efficiently, FAIL if batch processing fails
- Step 7: PASS if preference override functionality works, FAIL if override doesn't work
- Step 8: PASS if confirmation notifications send correctly, FAIL if confirmations fail
- Step 9: PASS if email content is accurate and professional, FAIL if content is wrong
- Step 10: PASS if error handling is robust, FAIL if system crashes on errors 
- Step 11: PASS if timing logic is accurate, FAIL if timing calculations wrong
- Step 12: PASS if management command integration works, FAIL if integration broken
- Step 13: PASS if frequency handling works as designed, FAIL if unexpected behavior
- Step 14: PASS if cleanup works, FAIL if cleanup fails

Critical Requirements for PASS:
1. Notifications sent only to students with enabled preferences (respect_preferences=True)
2. Email content is accurate, personalized, and professional
3. Batch notification processing works efficiently
4. Error handling prevents system crashes
5. Timing calculations are accurate for expiry windows
6. Integration with management command works properly
7. Confirmation notifications sent after processing
8. Preference override functionality works when needed

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails