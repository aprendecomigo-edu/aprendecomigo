QA Test Case: Stripe Integration and Payment Intent Tests

Test ID: TRANSACTIONS-003
Test Name: Stripe Integration and Payment Intent Tests
Purpose: Verify Stripe payment intent ID constraints, customer ID handling, uniqueness validation, and integration with payment processing workflow
Expected Result: All Stripe integration fields work correctly with proper constraints, validation, and payment workflow support

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- Feature: PurchaseTransaction Stripe integration fields
- Model Fields: stripe_payment_intent_id (unique), stripe_customer_id
- Stripe ID Formats: Payment Intent IDs start with "pi_", Customer IDs start with "cus_"
- Database Constraints: Unique constraint on stripe_payment_intent_id
- Integration: Supports Stripe webhook processing and payment tracking

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Django Development Server: localhost:8000
3. Test Environment: Development database
4. Admin Access: Django admin interface

Test Data Requirements:
- Test Stripe payment intent IDs (realistic format)
- Test Stripe customer IDs (realistic format)
- Multiple test students
- Various transaction scenarios

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Stripe Format Verification
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

1. Navigate to http://localhost:8000/admin/
2. Access PurchaseTransaction admin
3. Review field specifications for Stripe integration
4. Verify field help text and validation rules

Expected: Admin interface shows Stripe fields with proper configuration
Screenshot: 01_stripe_field_configuration.png

Step 2: Test Valid Stripe Payment Intent ID Formats
1. Create new transaction with valid payment intent ID:
   - stripe_payment_intent_id: pi_1A2B3C4D5E6F7G8H9I0J1K2L
   - stripe_customer_id: cus_ABCDEFGHIJklmnop12345678
   - Other required fields (student, amount, etc.)
2. Save and verify acceptance

Expected: Transaction saves successfully with Stripe IDs
Screenshot: 02_valid_stripe_ids.png

Step 3: Test Stripe Payment Intent ID Uniqueness Constraint
1. Create first transaction with: pi_uniqueness_test_001
2. Save successfully
3. Create second transaction with same payment intent ID
4. Attempt to save and observe constraint violation

Expected: 
- First transaction saves successfully
- Second transaction rejected with unique constraint error
- Error message clearly indicates duplicate payment intent ID

Screenshot: 03_uniqueness_constraint_test.png

Step 4: Test Edge Cases for Stripe Payment Intent IDs
1. Test with minimum length ID: pi_123
2. Test with maximum realistic length: pi_1234567890123456789012345678901234567890
3. Test with special characters: pi_test-payment_intent.001
4. Test with uppercase: PI_TEST123456789
5. Verify field length constraints (max_length=255)

Expected: All valid formats accepted, length constraints enforced
Screenshot: 04_payment_intent_edge_cases.png

Step 5: Test Stripe Customer ID Validation
1. Create transactions with various customer ID formats:
   - Standard format: cus_ABCDEFGHIJklmnop
   - Longer format: cus_1234567890abcdefghijklmnopqrstuvwxyz
   - Test format: cus_test_customer_001
2. Verify all formats accepted
3. Test field length constraints

Expected: All realistic customer ID formats accepted
Screenshot: 05_customer_id_validation.png

Step 6: Test Null and Blank Stripe Fields
1. Create transaction with stripe_payment_intent_id = null/blank
2. Create transaction with stripe_customer_id = null/blank
3. Create transaction with both fields null/blank
4. Verify all scenarios work (fields are optional)

Expected: Null/blank values accepted for both Stripe fields
Screenshot: 06_null_blank_stripe_fields.png

Step 7: Test Search Functionality by Stripe IDs
1. Create several transactions with different Stripe IDs
2. Use admin search box to find by payment intent ID
3. Use admin search box to find by customer ID
4. Test partial matches and exact matches
5. Verify search results accuracy

Expected: Search finds transactions by both Stripe ID types
Screenshot: 07_stripe_id_search.png

Step 8: Test Filtering by Stripe Integration Fields
1. Create mix of transactions:
   - Some with Stripe IDs populated
   - Some with Stripe IDs blank/null
2. Use admin filters to show only transactions with Stripe data
3. Filter by specific Stripe ID patterns
4. Verify filter accuracy

Expected: Filters work correctly for Stripe integration status
Screenshot: 08_stripe_filtering.png

Step 9: Test Stripe ID Display in List View
1. Review transaction list view
2. Verify stripe_payment_intent_id displays correctly
3. Check column width and text truncation
4. Verify full ID visible on hover or click
5. Test with very long payment intent IDs

Expected: Stripe IDs display clearly in admin list view
Screenshot: 09_stripe_id_display.png

Step 10: Test Bulk Operations with Stripe Data
1. Create multiple transactions with Stripe IDs
2. Select multiple transactions for bulk status update
3. Verify Stripe data preserved during bulk operations
4. Test bulk actions don't corrupt Stripe IDs

Expected: Bulk operations preserve Stripe integration data
Screenshot: 10_bulk_operations_stripe_data.png

Step 11: Test Stripe Webhook Simulation Scenarios
1. Create transaction representing Stripe payment flow:
   - Create with PENDING status and payment intent ID
   - Simulate "payment_intent.succeeded" by marking completed
   - Verify payment intent ID preserved throughout
2. Create failure scenario:
   - PENDING â†’ FAILED status change
   - Verify Stripe data intact

Expected: Status changes preserve Stripe integration data
Screenshot: 11_webhook_simulation.png

Step 12: Test Stripe Customer ID Consistency
1. Create multiple transactions for same student
2. Use same stripe_customer_id across transactions
3. Verify customer ID consistency per student
4. Test scenarios where customer ID changes (customer update)

Expected: Customer ID consistency maintained appropriately
Screenshot: 12_customer_id_consistency.png

Step 13: Test Large Stripe ID Datasets
1. Create 50+ transactions with unique payment intent IDs
2. Test admin performance with large Stripe ID dataset
3. Verify uniqueness constraint performance
4. Test search performance with large ID dataset

Expected: Good performance even with large datasets
Screenshot: 13_large_dataset_performance.png

Step 14: Test Stripe ID Export and Import Scenarios
1. Export transaction data including Stripe IDs
2. Verify Stripe IDs export correctly
3. Test scenarios where data might be re-imported
4. Verify uniqueness constraints work during import

Expected: Stripe IDs handle export/import scenarios properly
Screenshot: 14_export_import_scenarios.png

Step 15: Test Invalid Stripe ID Formats
1. Try to create transaction with invalid payment intent format:
   - Wrong prefix: si_invalid123456789
   - No prefix: 123456789012345678
   - Invalid characters: pi_test@invalid#id
2. Verify system behavior with invalid formats

Expected: System accepts any string format (no strict validation) but maintains data integrity
Screenshot: 15_invalid_format_handling.png

Step 16: Test Stripe ID Field Editing
1. Create transaction with Stripe IDs
2. Edit to change payment intent ID to different valid ID
3. Edit to remove Stripe IDs (set to blank)
4. Edit to add Stripe IDs to transaction without them
5. Verify all edit scenarios work correctly

Expected: Stripe ID fields fully editable with proper validation
Screenshot: 16_stripe_id_editing.png

Step 17: Test Concurrent Stripe ID Operations
1. Attempt to create multiple transactions simultaneously with same payment intent ID
2. Test race condition scenarios
3. Verify database constraint prevents duplicates even under concurrency
4. Check for proper error handling

Expected: Uniqueness constraint prevents duplicates under all conditions
Screenshot: 17_concurrent_operations.png

Step 18: Test Stripe Integration with Transaction Types
1. Create package transaction with Stripe IDs
2. Create subscription transaction with Stripe IDs
3. Verify Stripe integration works equally for both types
4. Test type-specific Stripe workflow scenarios

Expected: Stripe integration works consistently across transaction types
Screenshot: 18_transaction_type_integration.png

Step 19: Test Stripe Field Validation Edge Cases
1. Test empty string vs null for Stripe fields
2. Test whitespace-only values
3. Test extremely long values (beyond 255 characters)
4. Test Unicode characters in Stripe IDs
5. Verify proper validation and error handling

Expected: Robust validation handles all edge cases appropriately
Screenshot: 19_validation_edge_cases.png

Step 20: Test Stripe Integration Audit Trail
1. Create transaction with Stripe IDs
2. Modify payment intent ID
3. Change status while preserving Stripe data
4. Verify audit trail captures Stripe ID changes
5. Check timestamp accuracy for Stripe-related changes

Expected: Stripe ID changes tracked in audit trail with proper timestamps
Screenshot: 20_stripe_audit_trail.png

=== PASS/FAIL CRITERIA ===

PASS: All Stripe integration features work correctly with proper validation, constraints, and data integrity
FAIL: Any Stripe field handling fails OR uniqueness constraints bypassable OR data corruption occurs OR integration workflow broken

Individual Step Criteria:
- Step 1: PASS if Stripe fields properly configured in admin, FAIL if fields missing or misconfigured
- Step 2: PASS if valid Stripe IDs accepted, FAIL if valid formats rejected
- Step 3: PASS if uniqueness constraint enforced, FAIL if duplicates allowed
- Step 4: PASS if edge cases handled properly, FAIL if valid formats rejected or constraints bypassed
- Step 5: PASS if customer ID validation works, FAIL if valid formats rejected
- Step 6: PASS if null/blank values accepted, FAIL if required when should be optional
- Step 7: PASS if search functionality works, FAIL if search fails or returns incorrect results
- Step 8: PASS if filtering accurate, FAIL if filters broken or inaccurate
- Step 9: PASS if display clear and usable, FAIL if IDs truncated or unreadable
- Step 10: PASS if bulk operations preserve Stripe data, FAIL if data corrupted during bulk actions
- Step 11: PASS if webhook simulation works, FAIL if status changes corrupt Stripe data
- Step 12: PASS if customer ID consistency maintained, FAIL if inconsistencies introduced
- Step 13: PASS if performance acceptable with large datasets, FAIL if significant performance degradation
- Step 14: PASS if export/import works, FAIL if data corruption during export/import
- Step 15: PASS if invalid formats handled gracefully, FAIL if system crashes or corrupts data
- Step 16: PASS if editing works properly, FAIL if edits fail or cause validation errors
- Step 17: PASS if concurrency handled correctly, FAIL if race conditions allow duplicates
- Step 18: PASS if integration consistent across types, FAIL if type-specific issues
- Step 19: PASS if edge case validation robust, FAIL if validation bypassed or crashes
- Step 20: PASS if audit trail accurate, FAIL if changes not tracked or timestamps wrong

Overall Result: PASS only if ALL steps pass, FAIL if ANY step fails

=== ADDITIONAL VERIFICATION POINTS ===

Stripe Field Specifications:
- stripe_payment_intent_id: CharField, max_length=255, unique=True, null=True, blank=True
- stripe_customer_id: CharField, max_length=255, null=True, blank=True
- Both fields indexed for query performance
- Help text provides clear guidance

Database Constraints:
- Unique constraint on stripe_payment_intent_id enforced at database level
- Index on stripe_payment_intent_id for search performance
- No cascading constraints (Stripe IDs are external references)

Integration Requirements:
- Support Stripe webhook event processing
- Enable payment intent tracking throughout lifecycle
- Customer ID consistency for multiple transactions per customer
- Handle Stripe API response data storage

Validation Rules:
- Payment intent IDs typically start with "pi_" but any string format accepted
- Customer IDs typically start with "cus_" but any string format accepted
- Maximum length 255 characters for both fields
- Null/blank values allowed for both fields
- Uniqueness enforced only for payment intent IDs

Performance Requirements:
- Uniqueness checks perform efficiently even with large datasets
- Search by Stripe IDs returns results quickly
- Admin list view loads promptly with Stripe ID display
- Bulk operations maintain performance with Stripe data

Error Handling:
- Clear error messages for uniqueness constraint violations
- Graceful handling of invalid Stripe ID formats
- Proper validation error display in admin interface
- No system crashes from malformed Stripe data