QA Test Case: Stripe Integration and Payment Processing

Test ID: PURCHASE-004
Test Name: Stripe Payment Intent Creation and Integration Testing
Purpose: Verify that the Purchase Initiation API correctly integrates with Stripe, creates valid payment intents, and handles Stripe-specific errors
Expected Result: Payment intents created successfully with correct amounts, metadata, and configuration

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- API Endpoint: POST /finances/api/purchase/initiate/
- Stripe Integration: Test mode with test API keys
- Payment Processing: Payment intent creation with EUR currency
- Metadata Handling: Custom metadata for transaction tracking

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root
3. Environment Variables:
   - DJANGO_ENV=development
   - STRIPE_SECRET_KEY=sk_test_... (must be valid test key)
   - STRIPE_PUBLISHABLE_KEY=pk_test_... (must be valid test key)
   - STRIPE_WEBHOOK_SECRET=whsec_... (for webhook testing)

Stripe Test Configuration:
- Mode: Test mode only (never production)
- Currency: EUR (European market)
- Payment Methods: Card payments with automatic payment methods
- Amount Format: Cents (€150.00 = 15000 cents)

Test Data:
- Valid pricing plans with different amounts
- User data for metadata testing
- Plan types: Both package and subscription

Stripe API Access:
- Direct Stripe API calls for verification
- Stripe CLI for webhook testing (optional)
- Stripe Dashboard for visual confirmation

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Stripe Configuration Verification
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Stripe Configuration Test:
  curl -X GET http://localhost:8000/finances/api/stripe/config/ \
    -H "Content-Type: application/json" \
    -v

Expected Response (HTTP 200):
{
  "public_key": "pk_test_...",
  "success": true
}

Stripe Connection Test:
  curl -X GET http://localhost:8000/finances/api/stripe/test-connection/ \
    -H "Authorization: Bearer <jwt_token>" \
    -H "Content-Type: application/json" \
    -v

Expected Response (HTTP 200):
{
  "success": true,
  "message": "Stripe API connection successful",
  "account_id": "acct_...",
  "livemode": false
}

Screenshot: 01_stripe_configuration_verified.png

Step 2: Basic Payment Intent Creation Test
1. Execute purchase API to create payment intent
2. Verify payment intent structure and properties

Command:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "Stripe Test User",
        "email": "stripe.test@example.com"
      }
    }' \
    -v

Expected Response (HTTP 201):
{
  "success": true,
  "client_secret": "pi_<payment_intent_id>_secret_<secret_key>",
  "transaction_id": <integer>,
  "payment_intent_id": "pi_<stripe_payment_intent_id>",
  "plan_details": {
    "id": 1,
    "name": "...",
    "price_eur": "150.00",
    "hours_included": "10.00"
  },
  "message": "Purchase of ... initiated successfully"
}

Validation:
- client_secret format: pi_XXXXXX_secret_XXXXXX
- payment_intent_id format: pi_XXXXXX
- Both IDs should match (same payment intent)

Screenshot: 02_payment_intent_created.png

Step 3: Direct Stripe API Verification
1. Use payment_intent_id to fetch from Stripe API
2. Verify payment intent properties and metadata

Command:
  curl -X GET https://api.stripe.com/v1/payment_intents/<payment_intent_id> \
    -H "Authorization: Bearer <STRIPE_SECRET_KEY>" \
    -v

Expected Stripe Response:
{
  "id": "pi_XXXXXX",
  "object": "payment_intent",
  "amount": 15000,
  "currency": "eur",
  "status": "requires_payment_method",
  "automatic_payment_methods": {
    "enabled": true
  },
  "metadata": {
    "user_id": "<user_id>",
    "pricing_plan_id": "1",
    "transaction_type": "package_purchase",
    "custom_plan_name": "...",
    "custom_student_name": "Stripe Test User",
    "custom_student_email": "stripe.test@example.com",
    "custom_hours_included": "10.00",
    "custom_price_eur": "150.00"
  },
  "client_secret": "pi_XXXXXX_secret_XXXXXX"
}

Verification Points:
- amount: 15000 (€150 in cents)
- currency: "eur"
- status: "requires_payment_method"
- automatic_payment_methods enabled
- metadata contains all required fields

Screenshot: 03_stripe_payment_intent_verified.png

Step 4: Payment Amount Calculations Testing
1. Test different pricing plans with various amounts
2. Verify correct cent conversion for all amounts

Test 4.1: Small amount (€25.50)
Assume plan with €25.50 price exists:

Command:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": <small_amount_plan_id>,
      "student_info": {
        "name": "Small Amount Test",
        "email": "small.amount@example.com"
      }
    }' \
    -v

Stripe Verification:
  curl -X GET https://api.stripe.com/v1/payment_intents/<payment_intent_id> \
    -H "Authorization: Bearer <STRIPE_SECRET_KEY>"

Expected: amount = 2550 (€25.50 * 100)

Test 4.2: Large amount (€500.00)
Command similar to above with different plan_id

Expected: amount = 50000 (€500.00 * 100)

Test 4.3: Decimal amount precision (€99.99)
Expected: amount = 9999 (€99.99 * 100)

Screenshot: 04_amount_calculations_verified.png

Step 5: Metadata Handling and Content Verification
1. Test that all required metadata is included
2. Verify metadata format and content accuracy

Metadata Verification for Different Plan Types:

Test 5.1: Package Plan Metadata
Database query to get plan details:
  cd backend
  python manage.py shell
  
  from finances.models import PricingPlan
  package_plan = PricingPlan.objects.filter(plan_type='package').first()
  print(f"Package Plan: {package_plan.name}")
  print(f"Price: {package_plan.price_eur}")
  print(f"Hours: {package_plan.hours_included}")
  print(f"Validity: {package_plan.validity_days}")

Purchase with package plan:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": <package_plan_id>,
      "student_info": {
        "name": "Package Metadata Test",
        "email": "package.metadata@example.com"
      }
    }' \
    -v

Expected Stripe metadata should include:
- custom_plan_type: "package"
- custom_validity_days: "<days>" (if applicable)
- custom_hours_included: "<hours>"
- custom_price_eur: "<price>"

Test 5.2: Subscription Plan Metadata (if subscriptions exist)
Similar test for subscription plan type with subscription-specific metadata

Screenshot: 05_metadata_verification.png

Step 6: Payment Method Configuration Testing
1. Verify automatic payment methods are enabled
2. Test payment method requirements

Payment Intent Configuration Check:
From Stripe API response, verify:
- automatic_payment_methods.enabled = true
- payment_method_options configured appropriately
- confirmation_method = "automatic" (default)

Payment Methods Available Test:
  curl -X GET https://api.stripe.com/v1/payment_methods \
    -G -d "type=card" \
    -H "Authorization: Bearer <STRIPE_SECRET_KEY>"

Expected: Should return available card payment methods for testing

Screenshot: 06_payment_methods_configuration.png

Step 7: Stripe Error Handling Testing
1. Test with invalid Stripe configuration
2. Verify proper error handling and messages

Test 7.1: Temporarily break Stripe config (for testing only)
Note: This test requires temporarily modifying config or using invalid key

Simulated Stripe Error Test:
1. Modify STRIPE_SECRET_KEY to invalid value (backup original first)
2. Restart services
3. Attempt purchase

Expected Response (HTTP 503 or 500):
{
  "success": false,
  "error_type": "api_connection_error",
  "message": "Payment service temporarily unavailable"
}

Test 7.2: Restore valid configuration and verify recovery
1. Restore original STRIPE_SECRET_KEY
2. Restart services
3. Verify normal operation restored

Screenshot: 07_stripe_error_handling.png

Step 8: Payment Intent Status Lifecycle Testing
1. Create payment intent and verify initial status
2. Test status transitions (if applicable)

Payment Intent Status Verification:
Initial status should be "requires_payment_method"

Advanced Status Testing (Optional):
If implementing payment completion in this test:
1. Use Stripe test cards to simulate payment
2. Verify status changes to "succeeded"
3. Check webhook handling (if implemented)

Test Payment Intent Updates:
  curl -X POST https://api.stripe.com/v1/payment_intents/<payment_intent_id> \
    -H "Authorization: Bearer <STRIPE_SECRET_KEY>" \
    -d "metadata[test_update]=true"

Expected: Payment intent should be updatable with additional metadata

Screenshot: 08_payment_status_lifecycle.png

Step 9: Currency and Internationalization Testing
1. Verify EUR currency is correctly set
2. Test amount formatting for European market

Currency Verification:
All payment intents should have:
- currency: "eur"
- Amounts in cents (European format)

International Formatting Test:
Verify that amounts are handled correctly:
- €1.50 = 150 cents
- €0.01 = 1 cent (minimum)
- €999.99 = 99999 cents (large amounts)

Database Transaction Currency Check:
  from finances.models import PurchaseTransaction
  
  latest_tx = PurchaseTransaction.objects.order_by('-created_at').first()
  print(f"Transaction amount: {latest_tx.amount}")
  print(f"Stripe metadata: {latest_tx.metadata}")

Expected: Amounts stored in EUR decimal format in database

Screenshot: 09_currency_internationalization.png

Step 10: Concurrent Payment Intent Creation
1. Test multiple simultaneous purchase requests
2. Verify no race conditions or duplicate payment intents

Concurrent Request Test:
Create script to run multiple purchase requests simultaneously:

Bash script (concurrent_test.sh):
```bash
#!/bin/bash
for i in {1..5}; do
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d "{
      \"plan_id\": 1,
      \"student_info\": {
        \"name\": \"Concurrent Test $i\",
        \"email\": \"concurrent$i@example.com\"
      }
    }" &
done
wait
```

Execute:
  chmod +x concurrent_test.sh
  ./concurrent_test.sh

Expected Results:
- All requests should succeed (5 x HTTP 201)
- Each should get unique payment_intent_id
- No duplicate client_secret values
- Database transactions created correctly

Database Verification:
  from finances.models import PurchaseTransaction
  
  concurrent_txs = PurchaseTransaction.objects.filter(
      student__email__startswith='concurrent'
  ).order_by('-created_at')[:5]
  
  print(f"Concurrent transactions created: {concurrent_txs.count()}")
  
  intent_ids = [tx.stripe_payment_intent_id for tx in concurrent_txs]
  unique_ids = set(intent_ids)
  print(f"Unique payment intent IDs: {len(unique_ids)}")
  
  # Should be 5 unique payment intents

Screenshot: 10_concurrent_requests_handled.png

=== PASS/FAIL CRITERIA ===

PASS: All Stripe integration working correctly AND payment intents created with proper configuration
FAIL: Any Stripe integration failure OR incorrect payment data OR security issues

Individual Step Criteria:
- Step 1: PASS if Stripe config accessible and connection test succeeds, FAIL if Stripe unavailable
- Step 2: PASS if payment intent created with valid format, FAIL if creation fails
- Step 3: PASS if Stripe API confirms payment intent with correct data, FAIL if mismatch
- Step 4: PASS if all amount calculations correct in cents, FAIL if any conversion error
- Step 5: PASS if metadata complete and accurate, FAIL if missing/incorrect metadata
- Step 6: PASS if payment methods configured correctly, FAIL if configuration issues
- Step 7: PASS if Stripe errors handled gracefully, FAIL if errors cause crashes
- Step 8: PASS if payment intent status correct, FAIL if status issues
- Step 9: PASS if EUR currency and formatting correct, FAIL if currency errors
- Step 10: PASS if concurrent requests handled properly, FAIL if race conditions

Stripe Integration Requirements:
- Valid test API keys working
- Payment intents created successfully
- Correct amount conversion (EUR to cents)
- Complete metadata inclusion
- Proper error handling for Stripe failures
- EUR currency consistently used

Payment Intent Requirements:
- Unique payment intent per request
- Correct amount in cents
- EUR currency setting
- Automatic payment methods enabled
- Complete metadata with user and plan info
- Valid client_secret format

Security Requirements:
- Test mode only (never production keys)
- No sensitive data in metadata
- Proper error message handling
- API key validation working
- No payment intent data leakage

Performance Requirements:
- Payment intent creation < 3 seconds
- Concurrent request handling without conflicts
- No memory leaks or connection issues
- Proper cleanup of failed payment intents

Overall Result: PASS only if ALL Stripe integration working AND payment intents properly configured