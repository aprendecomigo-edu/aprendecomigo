QA Test Case: Guest User Purchase and Registration

Test ID: PURCHASE-002
Test Name: Guest User Purchase Initiation and Automatic User Creation
Purpose: Verify that guest users can initiate purchases and the system properly creates user accounts and handles email matching logic
Expected Result: Guest purchase creates new user account, transaction record, and payment intent

=== CONTEXT (Pre-test Requirements) ===

System Information:
- Project: Aprende Comigo - Educational platform
- API Endpoint: POST /finances/api/purchase/initiate/ (unauthenticated access)
- User Creation: Automatic guest user creation with email matching
- Email Validation: Prevents duplicate accounts with case-insensitive matching

Required Environment Setup:
1. Project Location: /Users/anapmc/Code/aprendecomigo/
2. Python Virtual Environment: .venv/ in project root
3. Environment Variables:
   - DJANGO_ENV=development
   - STRIPE_SECRET_KEY=sk_test_... (test mode)

Test Data:
- New Guest Email: guest.test@example.com (ensure this email doesn't exist)
- Guest Name: Guest Test User
- Existing User Email: anapmc.carvalho@gmail.com (for collision testing)
- Plan Type: Package (basic tutoring hours)

Guest User Logic:
- API allows unauthenticated requests
- Creates new user with no password
- Case-insensitive email matching
- Associates purchase with created/found user

=== DETAILED STEP-BY-STEP INSTRUCTIONS ===

Step 1: Environment Setup and Database State Check
Commands:
  cd /Users/anapmc/Code/aprendecomigo
  source .venv/bin/activate
  make dev

Expected: Both services start successfully

Pre-test Database Check:
  cd backend
  python manage.py shell
  
  from accounts.models import CustomUser
  
  # Verify test email doesn't exist
  try:
      existing_user = CustomUser.objects.get(email__iexact="guest.test@example.com")
      print(f"WARNING: Test email already exists: {existing_user.id}")
  except CustomUser.DoesNotExist:
      print("✓ Test email is available for new user creation")
  
  # Count total users before test
  initial_user_count = CustomUser.objects.count()
  print(f"Initial user count: {initial_user_count}")

Screenshot: 01_environment_setup_guest_test.png

Step 2: Guest Purchase with New Email
1. Execute purchase API call without authentication
2. Use email that doesn't exist in system
3. Verify automatic user creation

Command:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "Guest Test User",
        "email": "guest.test@example.com"
      }
    }' \
    -v

Expected Response (HTTP 201 Created):
{
  "success": true,
  "client_secret": "pi_<payment_intent_id>_secret_<secret>",
  "transaction_id": <integer>,
  "payment_intent_id": "pi_<stripe_payment_intent_id>",
  "plan_details": {
    "id": 1,
    "name": "...",
    "plan_type": "package",
    "hours_included": "...",
    "price_eur": "..."
  },
  "message": "Purchase of ... initiated successfully"
}

Response Validation:
- HTTP 201 status (purchase created)
- Valid client_secret format
- Positive transaction_id
- Complete plan_details object

Screenshot: 02_guest_purchase_successful.png

Step 3: Verify New User Account Creation
1. Check that new user was created in database
2. Verify user properties (no password, correct email/name)
3. Confirm user count increased

Database Verification Commands:
  python manage.py shell
  
  from accounts.models import CustomUser
  from finances.models import PurchaseTransaction
  
  # Verify new user was created
  new_user = CustomUser.objects.get(email__iexact="guest.test@example.com")
  print(f"New user ID: {new_user.id}")
  print(f"User name: {new_user.name}")
  print(f"User email: {new_user.email}")
  print(f"Has password: {new_user.has_usable_password()}")
  print(f"Date joined: {new_user.date_joined}")
  
  # Verify transaction is linked to new user
  transaction = PurchaseTransaction.objects.filter(student=new_user).first()
  print(f"Transaction exists: {transaction is not None}")
  if transaction:
      print(f"Transaction amount: {transaction.amount}")
      print(f"Payment status: {transaction.payment_status}")
  
  # Verify user count increased
  final_user_count = CustomUser.objects.count()
  print(f"User count increased by: {final_user_count - initial_user_count}")

Expected Database State:
- New user created with guest.test@example.com
- User has no usable password (guest account)
- User name matches provided data
- Transaction linked to new user
- User count increased by 1

Screenshot: 03_new_user_account_verified.png

Step 4: Guest Purchase with Existing Email (Case Insensitive)
1. Test purchase with existing user email
2. Verify system uses existing user instead of creating duplicate
3. Test case-insensitive email matching

Test with existing email (different case):
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "Different Name",
        "email": "ANAPMC.CARVALHO@GMAIL.COM"
      }
    }' \
    -v

Expected Response:
- HTTP 201 Created (purchase successful)
- Valid client_secret and transaction_id
- Should use existing user, not create new one

Database Verification:
  from accounts.models import CustomUser
  from finances.models import PurchaseTransaction
  
  # Verify no duplicate user created
  users_with_email = CustomUser.objects.filter(
      email__iexact="anapmc.carvalho@gmail.com"
  )
  print(f"Users with test email: {users_with_email.count()}")
  
  # Check if transaction was created for existing user
  existing_user = users_with_email.first()
  recent_transactions = PurchaseTransaction.objects.filter(
      student=existing_user
  ).order_by('-created_at')[:2]
  
  print(f"Recent transactions for existing user: {recent_transactions.count()}")
  for tx in recent_transactions:
      print(f"  Transaction {tx.id}: {tx.created_at}")

Expected:
- Only 1 user with that email (no duplicate)
- New transaction created for existing user
- Case-insensitive matching working

Screenshot: 04_existing_user_case_insensitive.png

Step 5: Email Validation and Sanitization Testing
1. Test email normalization (lowercase conversion)
2. Test valid email formats
3. Test invalid email rejection

Valid Email Normalization Test:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "Email Test User",
        "email": "EMAIL.NORMALIZE@EXAMPLE.COM"
      }
    }' \
    -v

Expected:
- HTTP 201 Created
- Email stored in lowercase in database

Invalid Email Test:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "Invalid Email User",
        "email": "invalid-email-format"
      }
    }' \
    -v

Expected Response (HTTP 400 Bad Request):
{
  "success": false,
  "error_type": "validation_error",
  "message": "student_info.email: Please provide a valid email address",
  "field_errors": {
    "student_info": {
      "email": ["Please provide a valid email address"]
    }
  }
}

Screenshot: 05_email_validation_testing.png

Step 6: Name Validation and Sanitization
1. Test name field validation
2. Test special character handling
3. Test maximum length limits

Valid Name with Special Characters:
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "José María O'\''Connor-Smith",
        "email": "special.name@example.com"
      }
    }' \
    -v

Expected:
- HTTP 201 Created
- Special characters (accents, apostrophes, hyphens) preserved

Invalid Name Test (dangerous characters):
  curl -X POST http://localhost:8000/finances/api/purchase/initiate/ \
    -H "Content-Type: application/json" \
    -d '{
      "plan_id": 1,
      "student_info": {
        "name": "<script>alert(\"test\")</script>",
        "email": "dangerous.name@example.com"
      }
    }' \
    -v

Expected Response (HTTP 400 Bad Request):
{
  "success": false,
  "error_type": "validation_error",
  "message": "student_info.name: Name contains invalid characters...",
  "field_errors": {
    "student_info": {
      "name": ["Name contains invalid characters. Only letters, spaces, hyphens, apostrophes, and dots are allowed."]
    }
  }
}

Screenshot: 06_name_validation_testing.png

Step 7: Student Account Balance Creation for Guests
1. Verify StudentAccountBalance created for new guest users
2. Check initial balance values
3. Confirm balance linking to transaction

Database Balance Check:
  from finances.models import StudentAccountBalance
  
  # Check balance for newly created guest user
  guest_user = CustomUser.objects.get(email__iexact="guest.test@example.com")
  balance = StudentAccountBalance.objects.get(student=guest_user)
  
  print(f"Balance ID: {balance.id}")
  print(f"Hours purchased: {balance.hours_purchased}")
  print(f"Hours consumed: {balance.hours_consumed}")
  print(f"Balance amount: {balance.balance_amount}")
  print(f"Created at: {balance.created_at}")

Expected Balance State:
- StudentAccountBalance record exists
- hours_purchased: 0.00 (not credited until payment completes)
- hours_consumed: 0.00
- balance_amount: 0.00
- Record created during purchase initiation

Screenshot: 07_guest_account_balance_created.png

Step 8: Payment Intent Metadata for Guest Users
1. Verify Stripe payment intent contains correct guest user data
2. Check metadata includes user identification info
3. Confirm payment amount and currency

Stripe Payment Intent Check:
  from finances.models import PurchaseTransaction
  
  # Get latest transaction for guest user
  guest_transaction = PurchaseTransaction.objects.filter(
      student__email__iexact="guest.test@example.com"
  ).order_by('-created_at').first()
  
  print(f"Payment Intent ID: {guest_transaction.stripe_payment_intent_id}")
  print(f"Transaction metadata: {guest_transaction.metadata}")

Stripe API Verification (optional):
  curl -X GET https://api.stripe.com/v1/payment_intents/<payment_intent_id> \
    -H "Authorization: Bearer <STRIPE_SECRET_KEY>" \
    -v

Expected Stripe Metadata:
- user_id: guest user's database ID
- student_name: provided guest name
- student_email: normalized guest email
- plan information included

Screenshot: 08_stripe_metadata_guest_user.png

=== PASS/FAIL CRITERIA ===

PASS: All guest user scenarios work correctly AND proper user management
FAIL: Any user creation/matching logic fails OR data inconsistency

Individual Step Criteria:
- Step 1: PASS if services start and database check successful, FAIL if any errors
- Step 2: PASS if guest purchase succeeds with 201 response, FAIL if any error
- Step 3: PASS if new user created with correct properties, FAIL if user creation fails
- Step 4: PASS if existing user reused (no duplicate), FAIL if duplicate created
- Step 5: PASS if email validation works correctly, FAIL if invalid emails accepted
- Step 6: PASS if name validation/sanitization works, FAIL if dangerous input accepted
- Step 7: PASS if StudentAccountBalance created for guest, FAIL if balance missing
- Step 8: PASS if payment intent has correct metadata, FAIL if data missing/incorrect

User Management Requirements:
- New users created for unknown emails
- Existing users reused for known emails
- Case-insensitive email matching
- No duplicate accounts created
- Guest users have no usable password

Security Requirements:
- Email validation prevents malformed emails
- Name sanitization prevents XSS attacks
- Input validation protects against injection
- Proper error messages (no system internals exposed)

Data Integrity Requirements:
- Every purchase creates transaction record
- Transaction linked to correct user (new or existing)
- StudentAccountBalance exists for all users
- Payment intent metadata complete and accurate

Overall Result: PASS only if ALL steps pass AND user management working correctly